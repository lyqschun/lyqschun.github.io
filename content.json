{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/10/02/hello-world/"},{"title":"leetcode-1-Two Sum","text":"description Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. common method 1234567891011121314class Solution { public int[] twoSum(int[] nums, int target) { int[] ret = new int[2]; for(int i =0; i&lt;nums.length-1 ;i++){ for (int j = i+1 ;j &lt; nums.length ;j++ ){ if (nums[i] + nums[j] == target){ ret = new int[]{i, j}; return ret; } } } return ret ; }} best method1234567891011121314151617class Solution { public int[] twoSum(int[] nums, int target) { int len=nums.length; HashMap&lt;Integer, Integer&gt; map=new HashMap&lt;&gt;(); map.put(nums[0], 0); for(int i=1;i&lt;len;i++){ if(map.containsKey(target-nums[i])){ int[] returnArray={map.get(target-nums[i]),i}; return returnArray; } else{ map.put(nums[i], i); } } int[] returnArray={0,0}; return returnArray; }}","link":"/2018/11/11/algorithm/leetcode-1-Two-Sum/"},{"title":"二分查找法模板的基本思想-leetcode35","text":"leetcode35给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 123456789101112131415输入: [1,3,5,6], 5输出: 2示例 2:输入: [1,3,5,6], 2输出: 1示例 3:输入: [1,3,5,6], 7输出: 4示例 4:输入: [1,3,5,6], 0输出: 0 传统解法： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Solution3 { public int searchInsert(int[] nums, int target) { int len = nums.length; if (nums[len - 1] &lt; target) { return len; } int left = 0; int right = len - 1; while (left &lt;= right) { int mid = (left + right) / 2; // 等于的情况最简单，我们应该放在第 1 个分支进行判断 if (nums[mid] == target) { return mid; } else if (nums[mid] &lt; target) { // 题目要我们返回大于或者等于目标值的第 1 个数的索引 // 此时 mid 一定不是所求的左边界， // 此时左边界更新为 mid + 1 left = mid + 1; } else { // 既然不会等于，此时 nums[mid] &gt; target // mid 也一定不是所求的右边界 // 此时右边界更新为 mid - 1 right = mid - 1; } } // 注意：一定得返回左边界 left， // 如果返回右边界 right 提交代码不会通过 // 【注意】下面我尝试说明一下理由，如果你不太理解下面我说的，那是我表达的问题 // 但我建议你不要纠结这个问题，因为我将要介绍的二分查找法模板，可以避免对返回 left 和 right 的讨论 // 理由是对于 [1,3,5,6]，target = 2，返回大于等于 target 的第 1 个数的索引，此时应该返回 1 // 在上面的 while (left &lt;= right) 退出循环以后，right &lt; left，right = 0 ，left = 1 // 根据题意应该返回 left， // 如果题目要求你返回小于等于 target 的所有数里最大的那个索引值，应该返回 right return left; }} 说明 a、当把二分查找法的循环可以进行的条件写成 while (left &lt;= right) 时，在写最后一句 return 的时候，如果不假思索，把左边界 left 返回回去，虽然写对了，但可以思考一下为什么不返回右边界 right 呢？ b、但是事实上，返回 left 是有一定道理的，如果题目换一种问法，你可能就要返回右边界 right，这句话不太理解没有关系，我也不打算讲得很清楚（在上面代码的注释中我已经解释了原因），因为实在太绕了，这不是我要说的重点。 二分查找法模板的基本思想1、首先把循环可以进行的条件写成 while(left &lt; right)，在退出循环的时候，一定有 left == right 成立，此时返回 left 或者 right 都可以或许你会问：退出循环的时候还有一个数没有看啊（退出循环之前索引 left 或 索引 right 上的值）？没有关系，我们就等到退出循环以后来看，甚至经过分析，有时都不用看，就能确定它是目标数值。 （什么时候需要看最后剩下的那个数，什么时候不需要，会在后面介绍。） 更深层次的思想是“夹逼法”或者称为“排除法”。 2、“神奇的”二分查找法模板的基本思想（特别重要）“排除法”即：在每一轮循环中排除一半以上的元素，于是在对数级别的时间复杂度内，就可以把区间“夹逼” 只剩下 1 个数，而这个数是不是我们要找的数，单独做一次判断就可以了。 “夹逼法”或者“排除法”是二分查找算法的基本思想，“二分”是手段，在目标元素不确定的情况下，“二分” 也是“最大熵原理”告诉我们的选择。 还是 LeetCode 第 35 题，下面给出使用 while (left &lt; right) 模板写法的 2 段参考代码，以下代码的细节部分在后文中会讲到，因此一些地方不太明白没有关系，暂时跳过即可。 参考代码 1：重点理解为什么候选区间的索引范围是 [0, size]。 12345678910111213141516171819202122232425262728from typing import Listclass Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: # 返回大于等于 target 的索引，有可能是最后一个 size = len(nums) # 特判 if size == 0: return 0 left = 0 # 如果 target 比 nums里所有的数都大，则最后一个数的索引 + 1 就是候选值，因此，右边界应该是数组的长度 right = size # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界 while left &lt; right: mid = left + (right - left) // 2 if nums[mid] &lt; target: left = mid + 1 else: assert nums[mid] &gt;= target # [1,5,7] 2 right = mid # 调试语句 # print('left = {}, right = {}, mid = {}'.format(left, right, mid)) return left 参考代码 2：对于是否接在原有序数组后面单独判断，不满足的时候，再在候选区间的索引范围 [0, size - 1] 内使用二分查找法进行搜索。 1234567891011121314151617181920212223242526from typing import Listclass Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: # 返回大于等于 target 的索引，有可能是最后一个 size = len(nums) # 特判 1 if size == 0: return 0 # 特判 2：如果比最后一个数字还要大，直接接在它后面就可以了 if target &gt; nums[-1]: return size left = 0 right = size - 1 # 二分的逻辑一定要写对，否则会出现死循环或者数组下标越界 while left &lt; right: mid = left + (right - left) // 2 if nums[mid] &lt; target: left = mid + 1 else: assert nums[mid] &gt;= target right = mid return left 细节、注意事项、调试方法1、前提：思考左、右边界，如果左、右边界不包括目标数值，会导致错误结果例：LeetCode 第 69 题：x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 分析：一个非负整数的平方根最小可能是 0 ，最大可能是它自己。因此左边界可以取 0 ，右边界可以取 x。可以分析得再细一点，但这道题没有必要，因为二分查找法会帮你排除掉不符合的区间元素。 例：LeetCode 第 287 题：寻找重复数 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 分析：题目告诉我们“其数字都在 1 到 n 之间（包括 1 和 n）”。因此左边界可以取 1 ，右边界可以取 n。 要注意 2 点： 如果 left 和 right 表示的是数组的索引，就要考虑“索引是否有效” ，即“索引是否越界” 是重要的定界依据； 左右边界一定要包括目标元素，例如 LeetCode 第 35 题：“搜索插入位置” ，当 target 比数组中的最后一个数字还要大（不能等于）的时候，插入元素的位置就是数组的最后一个位置 + 1，即 (len - 1 + 1 =) len，如果忽略掉这一点，把右边界定为 len - 1 ，代码就不能通过在线测评。 2、中位数先写 int mid = (left + right) &gt;&gt;&gt; 1 ; 根据循环里分支的编写情况，再做调整理解这一点，首先要知道：当数组的元素个数是偶数的时候，中位数有左中位数和右中位数之分。 当数组的元素个数是偶数的时候：使用 int mid = left + (right - left) / 2 ; 得到左中位数的索引； 使用 int mid = left + (right - left + 1) / 2 ; 得到右中位数的索引。 当数组的元素个数是奇数的时候，以上二者都能选到最中间的那个中位数。其次， int mid = left + (right - left) / 2 ; 等价于 int mid = (left + right) &gt;&gt;&gt; 1； int mid = left + (right - left + 1) / 2 ; 等价于 int mid = (left + right + 1) &gt;&gt;&gt; 1 。 我们使用一个具体的例子来验证：当左边界索引 left = 3，右边界索引 right = 4 的时候， mid1 = left + (right - left) // 2 = 3 + (4 - 3) // 2 = 3 + 0 = 3， mid2 = left + (right - left + 1) // 2 = 3 + (4 - 3 + 1) // 2 = 3 + 1 = 4。 左中位数 mid1 是索引 left，右中位数 mid2 是索引 right。 记忆方法： (right - left) 不加 11 选左中位数，加 11 选右中位数。 那么，什么时候使用左中位数，什么时候使用右中位数呢？选中位数的依据是为了避免死循环，得根据分支的逻辑来选择中位数，而分支逻辑的编写也有技巧，下面具体说。 3、先写逻辑上容易想到的分支逻辑，这个分支逻辑通常是排除中位数的逻辑；在逻辑上，“可能是也有可能不是”让我们感到犹豫不定，但**“一定不是”是我们非常坚决的，通常考虑的因素特别单一，因此“好想” **。在生活中，我们经常听到这样的话：找对象时，“有车、有房，可以考虑，但没有一定不要”；找工作时，“事儿少、离家近可以考虑，但是钱少一定不去”，就是这种思想的体现。 例：LeetCode 第 69 题：x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 分析：因为题目中说“返回类型是整数，结果只保留整数的部分，小数部分将被舍去”。例如 55 的平方根约等于 2.2362.236，在这道题应该返回 22。因此如果一个数的平方小于或者等于 x，那么这个数有可能是也有可能不是 x 的平方根，但是能很肯定的是，如果一个数的平方大于 x ，这个数肯定不是 x 的平方根。 注意：先写“好想”的分支，排除了中位数之后，通常另一个分支就不排除中位数，而不必具体考虑另一个分支的逻辑的具体意义，且代码几乎是固定的。 4、循环内只写两个分支，一个分支排除中位数，另一个分支不排除中位数，循环中不单独对中位数作判断既然是“夹逼”法，没有必要在每一轮循环开始前单独判断当前中位数是否是目标元素，因此分支数少了一支，代码执行效率更高。 以下是“排除中位数的逻辑”思考清楚以后，可能出现的两个模板代码。 可以排除“中位数”的逻辑，通常比较好想，但并不绝对，这一点视情况而定。 分支条数变成 2 条，比原来 3 个分支要考虑的情况少，好处是： 不用在每次循环开始单独考虑中位数是否是目标元素，节约了时间，我们只要在退出循环的时候，即左右区间压缩成一个数（索引）的时候，去判断这个索引表示的数是否是目标元素，而不必在二分的逻辑中单独做判断。 这一点很重要，希望读者结合具体练习仔细体会，每次循环开始的时候都单独做一次判断，在统计意义上看，二分时候的中位数恰好是目标元素的概率并不高，并且即使要这么做，也不是普适性的，不能解决绝大部分的问题。 还以 LeetCode 第 35 题为例，通过之前的分析，我们需要找到“大于或者等于目标值的第 1 个数的索引”。对于这道题而言： 如果中位数小于目标值，它就应该被排除，左边界 left 就至少是 mid + 1； 如果中位数大于等于目标值，还不能够肯定它就是我们要找的数，因为要找的是等于目标值的第 11 个数的索引，中位数以及中位数的左边都有可能是符合题意的数，因此右边界就不能把 mid 排除，因此右边界 right 至多是 mid，此时右边界不向左边收缩。 下一点就更关键了。 5、根据分支逻辑选择中位数的类型，可能是左中位数，也可能是右位数，选择的标准是避免死循环 死循环容易发生在区间只有 22 个元素时候，此时中位数的选择尤为关键。选择中位数的依据是：避免出现死循环。我们需要确保： （下面的这两条规则说起来很绕，可以暂时跳过）。 如果分支的逻辑，在选择左边界的时候，不能排除中位数，那么中位数就选“右中位数”，只有这样区间才会收缩，否则进入死循环； 同理，如果分支的逻辑，在选择右边界的时候，不能排除中位数，那么中位数就选“左中位数”，只有这样区间才会收缩，否则进入死循环。 理解上面的这个规则可以通过具体的例子。针对以上规则的第 1 点：如果分支的逻辑，在选择左边界的时候不能排除中位数，例如： 1234567891011while left &lt; right: # 不妨先写左中位数，看看你的分支会不会让你代码出现死循环，从而调整 mid = left + (right - left) // 2 # 业务逻辑代码 if (check(mid)): # 选择右边界的时候，可以排除中位数 right = mid - 1 else: # 选择左边界的时候，不能排除中位数 left = mid 在区间中的元素只剩下 22 个时候，例如：left = 3，right = 4。此时左中位数就是左边界，如果你的逻辑执行到 left = mid 这个分支，且你选择的中位数是左中位数，此时左边界就不会得到更新，区间就不会再收缩（理解这句话是关键），从而进入死循环；为了避免出现死循环，你需要选择中位数是右中位数，当逻辑执行到 left = mid 这个分支的时候，因为你选择了右中位数，让逻辑可以转而执行到 right = mid - 1 让区间收缩，最终成为 1 个数，退出 while 循环。上面这段话不理解没有关系，因为我还没有举例子，你有个印象就好，类似地，理解选择中位数的依据的第 2 点。 6、退出循环的时候，可能需要对“夹逼”剩下的那个数单独做一次判断，这一步称之为“后处理”。二分查找法之所以高效，是因为它利用了数组有序的特点，在每一次的搜索过程中，都可以排除将近一半的数，使得搜索区间越来越小，直到区间成为一个数。回到这一节最开始的疑问：“区间左右边界相等（即收缩成 1 个数）时，这个数是否会漏掉”，解释如下： 如果你的业务逻辑保证了你要找的数一定在左边界和右边界所表示的区间里出现，那么可以放心地返回 left 或者 right，无需再做判断； 如果你的业务逻辑不能保证你要找的数一定在左边界和右边界所表示的区间里出现，那么只要在退出循环以后，再针对 nums[left] 或者 nums[right] （此时 nums[left] == nums[right]）单独作一次判断，看它是不是你要找的数即可，这一步操作常常叫做“后处理”。 如果你能确定候选区间里目标元素一定存在，则不必做“后处理”。例：LeetCode 第 69 题：x 的平方根 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 分析：非负实数 x 的平方根在 [0, x] 内一定存在，故退出 while (left &lt; right) 循环以后，不必单独判断 left 或者 right 是否符合题意。 如果你不能确定候选区间里目标元素一定存在，需要单独做一次判断。例：LeetCode 第 704 题：二分查找 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 分析：因为目标数有可能不在数组中，当候选区间夹逼成一个数的时候，要单独判断一下这个数是不是目标数，如果不是，返回 -1。 7、取中位数的时候，要避免在计算上出现整型溢出；int mid = (left + right) / 2; 的问题：在 left 和 right 很大的时候，left + right 会发生整型溢出，变成负数，这是一个 bug ，得改！ int mid = left + (right - left) / 2; 在 right 很大、 left 是负数且很小的时候， right - left 也有可能超过 int 类型能表示的最大值，只不过一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此 right - left 溢出的可能性很小。因此，它是正确的写法。下面介绍推荐的写法。 int mid = (left + right) &gt;&gt;&gt; 1; 如果这样写， left + right 在发生整型溢出以后，会变成负数，此时如果除以 22 ，mid 是一个负数，但是经过无符号右移，可以得到在不溢出的情况下正确的结果。 解释“无符号右移”：在 Java 中，无符号右移运算符 &gt;&gt;&gt; 和右移运算符 &gt;&gt; 的区别如下： 右移运算符 &gt;&gt; 在右移时，丢弃右边指定位数，左边补上符号位；无符号右移运算符 &gt;&gt;&gt; 在右移时，丢弃右边指定位数，左边补上 00，也就是说，对于正数来说，二者一样，而负数通过 &gt;&gt;&gt; 后能变成正数。下面解释上面的模板中，取中位数的时候使用先用“＋”，然后“无符号右移”。 a、int mid = (left + right) / 2 与 int mid = left + (right - left) / 2 两种写法都有整型溢出的风险，没有哪一个是绝对安全的，注意：这里我们取平均值用的是除以 2，并且是整除： int mid = (left + right) / 2 在 left 和 right 都很大的时候会溢出；int mid = left + (right - left) / 2 在 right 很大，且 left 是负数且很小的时候会溢出；b、写算法题的话，一般是让你在数组中做二分查找，因此 left 和 right 一般都表示数组的索引，因此 left 在绝大多数情况下不会是负数并且很小，因此使用 int mid = left + (right - left) // 2 相对 int mid = (left + right) // 2 更安全一些，并且也能向别人展示我们注意到了整型溢出这种情况，但事实上，还有更好的方式； c、建议使用 int mid = (left + right) &gt;&gt;&gt; 1 这种写法，其实是大有含义的： JDK8 中采用 int mid = (left + right) &gt;&gt;&gt; 1 ，重点不在 + ，而在 &gt;&gt;&gt; 。 我们看极端的情况，left 和 high 都是整型最大值的时候，注意，此时 3232 位整型最大值它的二进制表示的最高位是 00，它们相加以后，最高位是 11 ，变成负数，但是再经过无符号右移 &gt;&gt;&gt;（重点是忽略了符号位，空位都以 00 补齐），就能保证使用 + 在整型溢出了以后结果还是正确的。 Java 中 Collections 和 Arrays 提供的 binarySearch 方法，我们点进去看 left 和 right 都表示索引，使用无符号右移又不怕整型溢出，那就用 int mid = (left + right) &gt;&gt;&gt; 1 好啦。位运算本来就比使用除法快，这样看来使用 + 和 &lt;&lt;&lt; 真的是又快又好了。 我想这一点可能是 JDK8 的编写者们更层次的考量。 看来以后写算法题，就用 int mid = (left + right) &gt;&gt;&gt; 1 吧，反正更多的时候 left 和 right 表示索引。 8、编码一旦出现死循环，输出必要的变量值、分支逻辑是调试的重要方法。当出现死循环的时候的调试方法：打印输出左右边界、中位数的值和目标值、分支逻辑等必要的信息。 按照我的经验，一开始编码的时候，稍不注意就很容易出现死循环，不过没有关系，你可以你的代码中写上一些输出语句，就容易理解“在区间元素只有 2 个的时候容易出现死循环”。具体编码调试的细节，可以参考我在「力扣」第 69 题：x 的平方根的题解《二分查找 + 牛顿法（Python 代码、Java 代码）》 。 总结总结一下，我爱用这个模板的原因、技巧、优点和注意事项： 原因：无脑地写 while left &lt; right: ，这样你就不用判断，在退出循环的时候你应该返回 left 还是 right，因为返回 left 或者 right 都对； 技巧：先写分支逻辑，并且先写排除中位数的逻辑分支（因为更多时候排除中位数的逻辑容易想，但是前面我也提到过，这并不绝对），另一个分支的逻辑你就不用想了，写出第 1 个分支的反面代码即可（下面的说明中有介绍），再根据分支的情况选择使用左中位数还是右中位数； 说明：这里再多说一句。如果从代码可读性角度来说，只要是你认为好想的逻辑分支，就把它写在前面，并且加上你的注释，这样方便别人理解，而另一个分支，你就不必考虑它的逻辑了。有的时候另一个分支的逻辑并不太好想，容易把自己绕进去。如果你练习做得多了，会形成条件反射。 我简单总结了一下，左右分支的规律就如下两点： 如果第 1 个分支的逻辑是“左边界排除中位数”（left = mid + 1），那么第 2 个分支的逻辑就一定是“右边界不排除中位数”（right = mid），反过来也成立； 如果第 2 个分支的逻辑是“右边界排除中位数”（right = mid - 1），那么第 2 个分支的逻辑就一定是“左边界不排除中位数”（left = mid），反之也成立。 “反过来也成立”的意思是：如果在你的逻辑中，“边界不能排除中位数”的逻辑好想，你就把它写在第 1 个分支，另一个分支是它的反面，你可以不用管逻辑是什么，按照上面的规律直接给出代码就可以了。能这么做的理论依据就是“排除法”。 在「力扣」第 287 题：寻找重复数的题解《二分法（Python 代码、Java 代码）》和这篇题解的评论区中，有我和用户@fighterhit 给出的代码，在一些情况下，我们先写了不排除中位数的逻辑分支，更合适的标准就是“哪个逻辑分支好想，就先写哪一个”，欢迎大家参与讨论。 优点：分支条数只有 2 条，代码执行效率更高，不用在每一轮循环中单独判断中位数是否符合题目要求，写分支的逻辑的目的是尽量排除更多的候选元素，而判断中位数是否符合题目要求我们放在最后进行，这就是第 5 点； 说明：每一轮循环开始都单独判断中位数是否符合要求，这个操作不是很有普适性，因为从统计意义上说，中位数直接就是你想找的数的概率并不大，有的时候还要看看左边，还要看看右边。不妨就把它放在最后来看，把候选区间“夹逼”到只剩 11 个元素的时候，视情况单独再做判断即可。 注意事项 1：左中位数还是右中位数选择的标准根据分支的逻辑而来，标准是每一次循环都应该让区间收缩，当候选区间只剩下 22 个元素的时候，为了避免死循环发生，选择正确的中位数类型。如果你实在很晕，不防就使用有 22 个元素的测试用例，就能明白其中的原因，另外在代码出现死循环的时候，建议你可以将左边界、右边界、你选择的中位数的值，还有分支逻辑都打印输出一下，出现死循环的原因就一目了然了； 注意事项 2：如果能确定要找的数就在候选区间里，那么退出循环的时候，区间最后收缩成为 11 个数后，直接把这个数返回即可；如果你要找的数有可能不在候选区间里，区间最后收缩成为 11 个数后，还要单独判断一下这个数是否符合题意。 最后给出两个模板，大家看的时候看注释，不必也无需记忆它们。 说明：我写的时候，一般是先默认将中位数写成左中位数，再根据分支的情况，看看是否有必要调整成右中位数，即是不是要在 (right - left) 这个括号里面加 11 。 虽说是两个模板，区别在于选中位数，中位数根据分支逻辑来选，原则是区间要收缩，且不出现死循环，退出循环的时候，视情况，有可能需要对最后剩下的数单独做判断。 我想我应该是成功地把你绕晕了，如果您觉得啰嗦的地方，就当我是“重要的事情说了三遍”吧，确实是重点的地方我才会重复说。当然，最好的理解这个模板的方法还是应用它。在此建议您不妨多做几道使用“二分查找法”解决的问题，用一下我说的这个模板，在发现问题的过程中，体会这个模板好用的地方，相信你一定会和我一样爱上这个模板的。 在「力扣」的探索版块中，给出了二分查找法的 3 个模板，我这篇文章着重介绍了第 2 个模板，但是我介绍的角度和这个版块中给出的角度并不一样，第 1 个模板被我“嫌弃”了，第 3 个模板我看过了，里面给出的例题也可以用第 2 个模板来完成，如果大家有什么使用心得，欢迎与我交流。 来源：力扣（LeetCode），作者：liweiwei1419","link":"/2019/12/05/algorithm/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-leetcode35/"},{"title":"算法成长之路leetcode1-4","text":"1.Two SumdescGiven an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. solutions.eg1.12345678910111213141516//24 ms 38 MB s.O(n^2) k.O(1)class Solution { public int[] twoSum(int[] nums, int target) { int[] result =new int[2]; for(int i = 0;i&lt;nums.length-1;i++){ for(int j = i+1;j&lt;nums.length;j++){ if(nums[i]+nums[j] == target){ result[0] = i; result[1] = j; return new int[]{i,j}; } } } return new int[0]; }} eg2.12345678910111213// 3 ms 37.2 MB s.O(n) k.O(n)class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer,Integer&gt; cache = new HashMap(); for(int i = 0;i&lt;nums.length;i++){ if(cache.get(nums[i]) != null){ return new int[]{cache.get(nums[i]),i}; } cache.put(target-nums[i],i); } return new int[0]; }} 2.Add Two NumbersdesYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. solutioneg1.1234567891011121314151617181920212223242526272829// 2 ms 44.7 MBclass Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int carry = 0; // 进位 ListNode head = new ListNode(0); ListNode cur = head; // 一定要用两个链表，不能用一个操作 while(l1 != null ||l2 != null|| carry != 0){ // lastSum当最后一位刚好进1的时候，需要在循环 int l1v = l1 == null?0:l1.val; int l2v = l2 == null?0:l2.val; int temp =l1v+l2v+carry; ListNode node; if(temp&gt;=10){ node = new ListNode(temp-10); lastSum = 1; }else{ node = new ListNode(temp); lastSum = 0; } if(l1 != null) l1 = l1.next; if(l2 != null) l2 = l2.next; cur.next = node; cur = node; } return head.next; }} 3.Longest Substring Without Repeating CharactersdescGiven a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. solutioneg1.123456789101112131415161718192021222324252627282930//2 ms 24.05% 36.9 MB 95.35%class Solution { public int lengthOfLongestSubstring(String s) { Set&lt;Character&gt; strSet = new HashSet(); int maxLen = 0; if(s != null &amp;&amp; s.length() &gt;0){ char ss[] = s.toCharArray(); //利用toCharArray方法转换 for (int i = 0; i &lt; ss.length-1; i++) { strSet.add(ss[i]); for(int j = i+1; j&lt;ss.length; j++){ int oL = strSet.size(); strSet.add(ss[j]); int cL = strSet.size(); if(oL != cL){ // 不相等时记下个数 if(cL &gt; maxLen){ maxLen = cL; } }else{ // 相等时 跳出此次循环 清空set strSet.clear(); break; } } } if(maxLen == 0){ // 全相等时 maxLen = 1; } } return maxLen; }} eg2.123456789101112131415161718// 2 ms 37.3 MBclass Solution { public int lengthOfLongestSubstring(String s) { int maxLength = 0; char[] chars = s.toCharArray(); int leftIndex = 0;//记录最左边相等时的值，然后向右滑动窗口 for (int j = 0; j &lt; chars.length; j++) { for (int innerIndex = leftIndex; innerIndex &lt; j; innerIndex++) { if (chars[innerIndex] == chars[j]) { maxLength = Math.max(maxLength, j - leftIndex); leftIndex = innerIndex + 1; break; } } } return Math.max(chars.length - leftIndex, maxLength); }} 4.Median of Two Sorted ArraysdescThere are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 123nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 123nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 solutioneg1.123456789101112131415161718192021222324252627282930// 20 ms 10.07%// 2.2 MB 99.84%class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int maxL = 0; if (nums1.length &gt;= nums2.length) { maxL = nums1.length; } else { maxL = nums2.length; } List&lt;Integer&gt; newList = new ArrayList(maxL); for (int i = 0; i &lt; maxL; i++) { if (i &lt; nums1.length) { newList.add(nums1[i]); } if (i &lt; nums2.length) { newList.add(nums2[i]); } } int size = newList.size(); int index = size / 2; newList.sort(Comparator.comparing(Integer::valueOf)); if (size % 2 == 0) { return (newList.get(index) + newList.get(index - 1)) / 2d; } else { return newList.get(index); } }} eg2.123456789101112131415161718192021222324252627282930313233class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int n = nums1.length + nums2.length; double res = 0.0; if (n &lt;= 0) { return res; } if ((n &amp; 1) == 0) { res = (findKth(nums1, nums2, 0, 0, n / 2) + findKth(nums1, nums2, 0, 0, n / 2 + 1)) / 2.0; } else { res = findKth(nums1, nums2, 0, 0, n / 2 + 1); } return res; } private int findKth(int[] nums1, int[] nums2, int start1, int start2, int k) { if (start1 &gt;= nums1.length) { return nums2[start2 + k - 1]; } if (start2 &gt;= nums2.length) { return nums1[start1 + k - 1]; } if (k == 1) { return Math.min(nums1[start1], nums2[start2]); } int left = start1 + k / 2 - 1 &gt;= nums1.length ? Integer.MAX_VALUE : nums1[start1 + k / 2 - 1]; int right = start2 + k / 2 - 1 &gt;= nums2.length ? Integer.MAX_VALUE : nums2[start2 + k / 2 - 1]; if (left &lt; right) { return findKth(nums1, nums2, start1 + k / 2, start2, k - k / 2); } return findKth(nums1, nums2, start1, start2 + k / 2, k - k / 2); }} eg3.12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 二分查找、分治算法class Solution { public double findMedianSortedArrays(int[] A, int[] B) { //m:A数组的长度 int m = A.length; //n:B数组的长度 int n = B.length; //如果A的长度大于B if (m &gt; n) { // to ensure m&lt;=n //交换AB数组，确保m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; } //设置两个指针，iMin为头指针，IMAX为尾指针，halfLen为中位数指针 int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; //如果头指针走向不大于尾指针，进行循环 while (iMin &lt;= iMax) { //i为中位数 int i = (iMin + iMax) / 2; //j为 int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j - 1] &gt; A[i]){ iMin = i + 1; // i is too small } else if (i &gt; iMin &amp;&amp; A[i - 1] &gt; B[j]) { iMax = i - 1; // i is too big } else { // i is perfect int maxLeft = 0; if (i == 0) { maxLeft = B[j-1]; } else if (j == 0) { maxLeft = A[i - 1]; } else { maxLeft = Math.max(A[i - 1], B[j - 1]); } if ( (m + n) % 2 == 1 ) { return maxLeft; } int minRight = 0; if (i == m) { minRight = B[j]; } else if (j == n) { minRight = A[i]; } else { minRight = Math.min(B[j], A[i]); } return (maxLeft + minRight) / 2.0; } } return 0d; }}","link":"/2019/11/05/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode1-4/"},{"title":"leetcode-2-Add Two Numbers","text":"Add Two Numbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. common 1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummyHead = new ListNode(0); // 一点要赋值一个节点，进行操作 ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) { int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; } if (carry &gt; 0) { curr.next = new ListNode(carry); } return dummyHead.next; }} best123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode head = new ListNode(0); int carry = 0; while(l1!=null||l2!=null||carry&gt;0) { ListNode itr = head; while(itr.next!=null) itr = itr.next; // 寻找最后一个节点 int sum = ( (l1==null ? 0 : l1.val) + (l2==null ? 0 : l2.val) + carry); carry = sum/10; ListNode temp = new ListNode(sum%10); itr.next = temp; if(l1!=null) l1 = l1.next; if(l2!=null) l2 = l2.next; } return head.next; }}","link":"/2018/11/16/algorithm/leetcode-2-Add-Two-Numbers/"},{"title":"算法成长之路leetcode11-12","text":"11. Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example1234Example:Input: [1,8,6,2,5,4,8,3,7]Output: 49 JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package algorithm;/** * 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。 * 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。 * 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 * * 说明：你不能倾斜容器，且 n 的值至少为 2。 * * * * 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 * * * * 示例: * * 输入: [1,8,6,2,5,4,8,3,7] * 输出: 49 * * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/container-with-most-water * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode11 { // 暴力解法 public static int maxArea(int[] height) { int max = 0; for (int i = 0; i &lt; height.length - 1; i++) { for (int j = i + 1; j &lt; height.length; j++) { max = Math.max(max, Math.min(height[i], height[j]) * (j-i)); } } return max; } // 官方 双指针法 /** * 算法 * * 这种方法背后的思路在于，两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。 * * 我们在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾。 * 此外，我们会使用变量 maxareamaxarea 来持续存储到目前为止所获得的最大面积。 * 在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 maxareamaxarea，并将指向较短线段的指针向较长线段那端移动一步。 * * 作者：LeetCode * 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * 算法流程： 设置双指针 ii,jj 分别位于容器壁两端，根据规则移动指针（后续说明），并且更新面积最大值 res，直到 i == j 时返回 res。 * * 指针移动规则与证明： 每次选定围成水槽两板高度 h[i]h[i],h[j]h[j] 中的短板，向中间收窄 11 格。以下证明： * * 设每一状态下水槽面积为 S(i, j)S(i,j),(0 &lt;= i &lt; j &lt; n)(0&lt;=i&lt;j&lt;n)，由于水槽的实际高度由两板中的短板决定， * 则可得面积公式 S(i, j) = min(h[i], h[j]) × (j - i)S(i,j)=min(h[i],h[j])×(j−i)。 * 在每一个状态下，无论长板或短板收窄 11 格，都会导致水槽 底边宽度 -1−1： * 若向内移动短板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 可能变大，因此水槽面积 S(i, j)S(i,j) 可能增大。 * 若向内移动长板，水槽的短板 min(h[i], h[j])min(h[i],h[j]) 不变或变小，下个水槽的面积一定小于当前水槽面积。 * 因此，向内收窄短板可以获取面积最大值。换个角度理解： * 若不指定移动规则，所有移动出现的 S(i, j)S(i,j) 的状态数为 C(n, 2)C(n,2)，即暴力枚举出所有状态。 * 在状态 S(i, j)S(i,j) 下向内移动短板至 S(i + 1, j)S(i+1,j)（假设 h[i] &lt; h[j]h[i]&lt;h[j] ）， * 则相当于消去了 {S(i, j - 1), S(i, j - 2), ... , S(i, i + 1)}S(i,j−1),S(i,j−2),...,S(i,i+1) 状态集合。 * 而所有消去状态的面积一定 &lt;= S(i, j)&lt;=S(i,j)： * 短板高度：相比 S(i, j)S(i,j) 相同或更短（&lt;= h[i]&lt;=h[i]）； * 底边宽度：相比 S(i, j)S(i,j) 更短。 * 因此所有消去的状态的面积都 &lt; S(i, j)&lt;S(i,j)。通俗的讲，我们每次向内移动短板，所有的消去状态都不会导致丢失面积最大值 。 * * * 作者：jyd * 链接：https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param height * @return */ public static int maxArea1(int[] height) { int maxarea = 0, l = 0, r = height.length - 1; while (l &lt; r) { // 计算面积，取最大值 maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l)); // 小的向大的一方移动，如果左边小于右边，左边向右边移动一位，即左++,l++，否则右移 if (height[l] &lt; height[r]) l++; else r--; } return maxarea; } public static int maxArea2(int[] height) { int i = 0, j = height.length - 1, res = 0; while(i &lt; j){ res = height[i] &lt; height[j] ? Math.max(res, (j - i) * height[i++]): Math.max(res, (j - i) * height[j--]); } return res; } // best one public static int maxArea3(int[] height) { int lastIndex = height.length - 1, max = 0, temp = 0; for (int i = 0; i &lt; lastIndex;) { // 取左右边上的最小的数 temp = Math.min(height[i], height[lastIndex]); // 计算 距离最大面积 if (temp * (lastIndex - i) &gt; max) { max = temp * (lastIndex - i); System.out.println(&quot;&quot; + i + &quot;,&quot; + lastIndex); } // 最小值在右边的话 右边往左边移动 while (temp &gt;= height[lastIndex] &amp;&amp; i &lt; lastIndex) lastIndex--; // 最小值在左边的话 左边往右移动 直到重合 while (temp &gt;= height[i] &amp;&amp; i &lt; lastIndex) i++; } return max; } public static void main(String[] args) { System.out.println(maxArea3(new int[]{10, 8, 6, 2, 5, 4, 8, 3, 7})); }} 12. Integer to RomanRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol ValueI 1V 5X 10L 50C 100D 500M 1000For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example1234567891011121314151617181920212223Example 1:Input: 3Output: &quot;III&quot;Example 2:Input: 4Output: &quot;IV&quot;Example 3:Input: 9Output: &quot;IX&quot;Example 4:Input: 58Output: &quot;LVIII&quot;Explanation: L = 50, V = 5, III = 3.Example 5:Input: 1994Output: &quot;MCMXCIV&quot;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package algorithm;/** * 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 * * 字符 数值 * I 1 * V 5 * X 10 * L 50 * C 100 * D 500 * M 1000 * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ， * 即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 * * 通常情况下，罗马数字中小的数字在大的数字的右边。 * 但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边， * 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地， * 数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： * * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 * 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 * * 示例 1: * * 输入: 3 * 输出: &quot;III&quot; * 示例 2: * * 输入: 4 * 输出: &quot;IV&quot; * 示例 3: * * 输入: 9 * 输出: &quot;IX&quot; * 示例 4: * * 输入: 58 * 输出: &quot;LVIII&quot; * 解释: L = 50, V = 5, III = 3. * 示例 5: * * 输入: 1994 * 输出: &quot;MCMXCIV&quot; * 解释: M = 1000, CM = 900, XC = 90, IV = 4. * * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/integer-to-roman * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode12 { /** * 执行用时 :6 ms, 在所有 java 提交中击败了的用户 * 内存消耗 :36.1 MB, 在所有 java 提交中击败了100.00%的用户 * @param num * @return */ public static String intToRoman(int num) { // 个位数 String[] map = new String[]{&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;}; // 十位数 String[] map1 = new String[]{&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;}; // 百位 String[] map2 = new String[]{&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;}; // 千位 String[] map3 = new String[]{&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;}; StringBuilder sb = new StringBuilder(); String[] res = new String[4]; int i = 10; int j = 0; while (num &gt; 0) { int temp = num % i; if (i &gt; 10) { temp = temp / (i / 10); } switch (j) { case 0: res[j++] = map[temp]; break; case 1: res[j++] = map1[temp]; break; case 2: res[j++] = map2[temp]; break; case 3: res[j++] = map3[temp]; break; } i = 10*i; if (j &gt; 3) { break; } } for (int k = res.length - 1; k &gt;= 0; k--) { sb.append(res[k]); } return sb.toString(); } /** * 贪心算法 * * 解题思路 * 参考大佬们的思路 吃透之后 写出来 * 贪心算法 我永远用最接近的去做比较 * * 如果我去小卖部买55元的东西 * * 你可以选择一张面值50的 和一张5块的 * 也可以给一张100的让老板找零 * 贪心算法就是前者 * * 假定我买3块的东西 我先用5块去比较 太多了 老板问 你还有小点的纸币没 我找不开 * 这时候 你给个两块 还差一块 又给了一块 * 看着很蠢 但是这确实有效 * * 作者：guo-tang-feng * 链接：https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-guo-tang-feng/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * @param num * @return */ public static String intToRoman1(int num) { StringBuilder stringBuilder = new StringBuilder(); int[] moneys = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; String[] moneyToStr = new String[]{&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;}; int index = 0; while (num &gt; 0) { // 如果大于最大的数 if (num &gt;= moneys[index]) { // 加进去 stringBuilder.append(moneyToStr[index]); // 把加进去的减掉 num -= moneys[index]; // 索引前移，num -= moneys[index] 还可能满足 num &gt;= moneys[index] // ，此时如果只index++，那么就漏掉一部分了，所以要index--，如2000减掉1000还有1000 还是应该和moneys[0]比较 index--; } // 索引后移 index++; } return stringBuilder.toString(); } public static void main(String[] args) { // 第一次超过100%用户的内存，有点小小激动 😂 System.out.println(intToRoman(400)); System.out.println(intToRoman1(1994)); }}","link":"/2019/12/17/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode11-12/"},{"title":"算法成长之路leetcode13-14","text":"13. Roman to IntegerRoman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9.X can be placed before L (50) and C (100) to make 40 and 90.C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example1234567891011121314151617181920212223Example 1:Input: &quot;III&quot;Output: 3Example 2:Input: &quot;IV&quot;Output: 4Example 3:Input: &quot;IX&quot;Output: 9Example 4:Input: &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3.Example 5:Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package algorithm;import java.util.HashMap;import java.util.Map;/** * 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 * * 字符 数值 * I 1 * V 5 * X 10 * L 50 * C 100 * D 500 * M 1000 * 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 * * 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例， * 例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边， * 所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。 * 这个特殊的规则只适用于以下六种情况： * * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 * 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 * * 示例 1: * * 输入: &quot;III&quot; * 输出: 3 * 示例 2: * * 输入: &quot;IV&quot; * 输出: 4 * 示例 3: * * 输入: &quot;IX&quot; * 输出: 9 * 示例 4: * * 输入: &quot;LVIII&quot; * 输出: 58 * 解释: L = 50, V= 5, III = 3. * 示例 5: * * 输入: &quot;MCMXCIV&quot; * 输出: 1994 * 解释: M = 1000, CM = 900, XC = 90, IV = 4. * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/roman-to-integer * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode13 { public static int romanToInt(String s) { int[] moneys = new int[]{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; String[] moneyToStr = new String[]{&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;}; char[] chars = s.toCharArray(); int result = 0; int tempJ = 0; for (int i = 0; i &lt; chars.length; ) { for (int j = tempJ; j &lt; moneyToStr.length; ) { // 从左往右开始一个字符一个字符匹配，匹配到一个字符后开始下一个 if (new String(new char[]{chars[i]}).equals(moneyToStr[j])) { result += moneys[j]; i++; // 此时下一次可能还会出现一样的字符如VV=20 tempJ = j; break; // 匹配到两个字符是开始下两个字符 } else if (i + 1 &lt; chars.length &amp;&amp; new String(new char[]{chars[i], chars[i + 1]}).equals(moneyToStr[j])) { result += moneys[j]; i += 2; // 下次出现的一定是一个字符的,如IV下次不会再出现IV 只能出现I tempJ = j + 1; break; } else { j++; } } } return result; } public static int romanToInt1(String s) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); map.put(&quot;I&quot;, 1); map.put(&quot;IV&quot;, 4); map.put(&quot;V&quot;, 5); map.put(&quot;IX&quot;, 9); map.put(&quot;X&quot;, 10); map.put(&quot;XL&quot;, 40); map.put(&quot;L&quot;, 50); map.put(&quot;XC&quot;, 90); map.put(&quot;C&quot;, 100); map.put(&quot;CD&quot;, 400); map.put(&quot;D&quot;, 500); map.put(&quot;CM&quot;, 900); map.put(&quot;M&quot;, 1000); int ans = 0; // 所有的字符，要么匹配两个要么匹配一个，没有其余的情况 for(int i = 0;i &lt; s.length();) { // 两个匹配的 if(i + 1 &lt; s.length() &amp;&amp; map.containsKey(s.substring(i, i+2))) { ans += map.get(s.substring(i, i+2)); // 匹配上后往后移两个 i += 2; } else { // 一个匹配上的 ans += map.get(s.substring(i, i+1)); // 匹配后往后移一个 i ++; } } return ans; } public static void main(String[] args) { System.out.println(romanToInt(&quot;XIX&quot;)); }} 14. Longest Common PrefixWrite a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example12345678910111213Example 1:Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Example 2:Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.Note:All given inputs are in lowercase letters a-z. JAVA题解水平扫描 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package algorithm;/** * 编写一个函数来查找字符串数组中的最长公共前缀。 * * 如果不存在公共前缀，返回空字符串 &quot;&quot;。 * * 示例 1: * * 输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] * 输出: &quot;fl&quot; * 示例 2: * * 输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] * 输出: &quot;&quot; * 解释: 输入不存在公共前缀。 * 说明: * * 所有输入只包含小写字母 a-z 。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/longest-common-prefix * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode14 { public static String longestCommonPrefix(String[] strs) { if (strs.length == 0) { return &quot;&quot;; } if (strs.length == 1) { return strs[0]; } int i = 0; String pre = &quot;&quot;; for (; i &lt; strs[0].length(); i++) { pre = strs[0].substring(0, i + 1); int j = 1; boolean end = false; for (; j &lt; strs.length; j++) { if (!strs[j].startsWith(pre)) { break; } if (pre.length() == strs[j].length()) { end = true; } } if (j == strs.length &amp;&amp; !end) { continue; } else if (j != strs.length) { if (pre.length() &gt; 1) { return pre.substring(0, pre.length() - 1); } else { return &quot;&quot;; } } else { return pre; } } return pre; } // 水平扫描法 public static String longestCommonPrefix1(String[] strs) { if (strs.length == 0) return &quot;&quot;; String prefix = strs[0]; // 1,2-&gt;s1,3-&gt;s2,4;前两个中找到前缀公共最长的s1,然后和第3个一起找出s2，以此类推 for (int i = 1; i &lt; strs.length; i++) // 不相等时为-1 while (strs[i].indexOf(prefix) != 0) { // 从后往前缩短，直到找到最长的 prefix = prefix.substring(0, prefix.length() - 1); // 找完都没找到的话返回空 if (prefix.isEmpty()) return &quot;&quot;; } return prefix; } public static void main(String[] args) { System.out.println(longestCommonPrefix1(new String[]{&quot;flower&quot;,&quot;fl&quot;,&quot;flight&quot;})); } // 水平扫描，单个字符逐一进行比较 public static String longestCommonPrefix2(String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; for (int i = 0; i &lt; strs[0].length() ; i++){ char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) { // 如果i == strs[j].length() 代表找出最短的，直接返回，或者不相等时直接返回 if (i == strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); } } // 到此处已经找完 return strs[0]; }} 分治算法 123456789101112131415161718192021222324252627282930public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; return longestCommonPrefix(strs, 0 , strs.length - 1);}private String longestCommonPrefix(String[] strs, int l, int r) { // 只有一个字符串的时候，返回此字符串 if (l == r) { return strs[l]; } else { int mid = (l + r)/2; // 找出左边最长前缀 String lcpLeft = longestCommonPrefix(strs, l , mid); // 找出右边最长前缀 String lcpRight = longestCommonPrefix(strs, mid + 1,r); // 左边右边中找出最长前缀 return commonPrefix(lcpLeft, lcpRight); }}String commonPrefix(String left,String right) { int min = Math.min(left.length(), right.length()); for (int i = 0; i &lt; min; i++) { // 循环最小的一边字符逐一比较,不相等时跳出 if ( left.charAt(i) != right.charAt(i) ) return left.substring(0, i); } return left.substring(0, min);} 二分查找法 1234567891011121314151617181920212223242526public String longestCommonPrefix(String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int low = 1; int high = minLen; while (low &lt;= high) { int middle = (low + high) / 2; if (isCommonPrefix(strs, middle)) low = middle + 1; else high = middle - 1; } return strs[0].substring(0, (low + high) / 2);}private boolean isCommonPrefix(String[] strs, int len){ String str1 = strs[0].substring(0,len); for (int i = 1; i &lt; strs.length; i++) if (!strs[i].startsWith(str1)) return false; return true;} 字典树给定一些键值字符串 S = [S 1 ,S 2 …S n ]，我们要找到字符串 q 与 S 的最长公共前缀。 这样的查询操作可能会非常频繁。 我们可以通过将所有的键值 S 存储到一颗字典树中来优化最长公共前缀查询操作。 如果你想学习更多关于字典树的内容，可以从 208. 实现 Trie (前缀树)开始。在字典树中，从根向下的每一个节点都代表一些键值的公共前缀。 但是我们需要找到字符串q 和所有键值字符串的最长公共前缀。 这意味着我们需要从根找到一条最深的路径，满足以下条件： 这是所查询的字符串 q 的一个前缀 路径上的每一个节点都有且仅有一个孩子。 否则，找到的路径就不是所有字符串的公共前缀 路径不包含被标记成某一个键值字符串结尾的节点。 因为最长公共前缀不可能比某个字符串本身长 算法 最后的问题就是如何找到字典树中满足上述所有要求的最深节点。 最有效的方法就是建立一颗包含字符串[S 1 …S n ] 的字典树。 然后在这颗树中匹配 q 的前缀。 我们从根节点遍历这颗字典树，直到因为不能满足某个条件而不能再遍历为止。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public String longestCommonPrefix(String q, String[] strs) { if (strs == null || strs.length == 0) return &quot;&quot;; if (strs.length == 1) return strs[0]; Trie trie = new Trie(); for (int i = 1; i &lt; strs.length ; i++) { trie.insert(strs[i]); } return trie.searchLongestPrefix(q);}class TrieNode { // 子节点的链接数组 private TrieNode[] links; private final int R = 26; private boolean isEnd; // 非空子节点的数量 private int size; public void put(char ch, TrieNode node) { links[ch -'a'] = node; size++; } public int getLinks() { return size; } // 假设方法 containsKey、isEnd、get、put 都已经实现了 // 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/}public class Trie { private TrieNode root; public Trie() { root = new TrieNode(); }// 假设方法 insert、search、searchPrefix 都已经实现了// 可以参考文章：https://leetcode.com/articles/implement-trie-prefix-tree/ private String searchLongestPrefix(String word) { TrieNode node = root; StringBuilder prefix = new StringBuilder(); for (int i = 0; i &lt; word.length(); i++) { char curLetter = word.charAt(i); if (node.containsKey(curLetter) &amp;&amp; (node.getLinks() == 1) &amp;&amp; (!node.isEnd())) { prefix.append(curLetter); node = node.get(curLetter); } else return prefix.toString(); } return prefix.toString(); }}","link":"/2019/12/24/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode13-14/"},{"title":"动态规划DP算法详解","text":"定义动态规划（dynamic programing）和分治法类似，都是通过组合子问题的解来求解原问题的解。（在经典排序算法中的二路归并排序和快速排序都用到了分而治之的思想-分治法）。 分治法是将原问题划分为没有交集，相互独立的子问题，并分别求解后再进行合并，求出原问题的解。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。分治法会做许多不必要的工作，它会反复地求解那些公共子问题。动态规划算法对每个子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都需要重新计算。 动态规划上用来求解最优化问题（optimization problem）。 可以按照下面四个步骤来设计一个动态规划算法： 1、刻画一个最优解的结构特征。 2、递归地定义最优解的值。 3、计算最优解的值，通常采用自底向上的方法。 4、利用计算出的信息构造一个最优解。 对于确定状态转移方程就在第一步和第二步中，首先要确定问题的决策对象，接着对决策对象划分阶段并确定各个阶段的状态变量，最后建立各阶段的状态变量的转移方程。 例如用dp[i]表示以序列中第i个数字结尾的最长递增子序列长度和最长公共子序列中用dp[i][j]表示的两个字符串中前 i、 j 个字符的最长公共子序列，我们就是通过对这两个数字量的不断求解最终得到答案的。这个数字量就被我们称为状态。状态是描述问题当前状况的一个数字量。首先，它是数字的，是可以被抽象出来保存在内存中的。其次，它可以完全的表示一个状态的特征，而不需要其他任何的辅助信息。最后，也是状态最重要的特点，状态间的转移完全依赖于各个状态本身，如最长递增子序列中，dp[x]的值由 dp[i](i &lt; x)的值确定。若我们在分析动态规划问题的时候能够找到这样一个符合以上所有条件的状态，那么多半这个问题是可以被正确解出的。所以说，解动态规划问题的关键，就是寻找一个好的状态。 最优子结构用动态规划求解最优化问题的第一步就是刻画一个最优解的结构特征。如果一个问题的最优解包含其子问题的最优解，我们称此问题具有最优子结构性质。因此，某个问题是否适合用动态规划，它是否具有最优子结构性质是一个好的标准。使用动态规划方法时，我们用子问题的最优解来构造原问题的最优解。 如何发掘最优子结构的性质？1、证明问题最优解的第一个组成部分是做出一个选择，而做出这个选择将会产生一个或多个待解的子问题。 2、对一个给定问题，在其可能的第一步选择中，假定已经知道哪种选择才会得到最优解。而我们并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。 3、给定获取的最优解选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。 4、利用“剪切-粘贴(cut and paste)”技术证明作为构成原问题最优解组成部分，每个子问题的解就是它本身的最优解。 反证法：假定子问题的解不是自身的最优解，那么我们就可以从原问题中剪切掉这些非最优解，将最优解粘贴进去，从而得到原问题一个更优的解，这个解与最初的解的前提假设矛盾。 刻画子问题空间的经验保持子问题空间尽量简单，只在必要时才扩展它。例如下一节的例子，求钢条切割的最大收益问题中，子问题空间包含的问题为：对每个i值，长度为i的钢条最优切割问题。 对于不同问题领域，最优子结构的不同体现在两个方面： 原问题的最优解中涉及到多个子问题。 在确定最优解使用哪些子问题时，需要考察多少种选择。 重叠子问题适合用动态规划方法求解最优化问题的第二个性质是子问题的空间必须足够小，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。动态规划算法会对重叠的子问题只求解一次，并保存在一张表里，需要用的时候直接查表即可，每次查表的时间代价为常量O(1)。 核心问题动态规划的核心是状态和状态转移方程。 在记忆化搜索中，可以为正在处理的表项声明一个引用，简化对它的读写操作； 动态规划解决的是多阶段决策问题； 1初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态 和分治法最大的区别在于：适合于用动态规划的问题，经过分解以后得到的子问题往往不是相互独立的（即下一个子阶段的求解是建立在上一个子阶段的基础之上，进行进一步的求解，而不是相互独立的问题） 动态规划问题一般由难到易分为一维动态规划，二维动态规划，多维动态规划，以及多变量动态规划问题。其中多维动态规划问题又可以进行降维。动态规划问题求解的最重要的一步就是求解出 状态转移方程 特性 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理. 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势，动态规划可以避免多次计算） 动态规划的解题核心主要分为两步： 第一步：状态的定义 第二步：状态转移方程的定义 在这里，我们为了避免混淆用“状态”这个词来替代“问题”这个词。“问题”表示的含义类似：题目、要求解的内容、题干中的疑问句这样的概念。状态表示我们在求解问题之中对问题的分析转化。 第一步：状态的定义 有的问题过于抽象，或者过于啰嗦干扰我们解题的思路，我们要做的就是将题干中的问题进行转化（换一种说法，含义不变）。转化成一系列同类问题的某个解的情况，比如说： 题目：求一个数列中最大连续子序列的和。 我们要将这个原问题转化为： 状态定义：Fk是第k项前的最大序列和，求F1～FN中最大值。 通过换一种表述方式，我们清晰的发现了解决问题的思路，如何求出F1～FN中的最大值是解决原问题的关键部分。上述将原问题转化成另一种表述方式的过程叫做：状态的定义。这样的状态定义给出了一种类似通解的思路，把一个原来毫无头绪的问题转换成了可以求解的问题。 第二步：状态转移方程的定义 在进行了状态的定义后，自然而然的想到去求解F1～FN中最大值。这也是状态定义的作用，让我们把一个总体的问题转化成一系列问题，而第二步：状态转移方程的定义则告诉我们如何去求解一个问题，对于上述已经转换成一系列问题我们要关注的点就在于：如何能够用前一项或者前几项的信息得到下一项，这种从最优子状态转换为下一个最优状态的思路就是动态规划的核心。对于上面的例子题目来说，状态转移方程的定义应该是： Fk=max{Fk-1+Ak,Ak}Fk是前k项的和，Ak是第k项的值 仔细思考一番，我们能够得到这样的结论，对于前k个项的最大子序列和是前k-1项的最大子序列和Fk与第k项的和、或者第k项两者中较大的。如果大家还是不能理解这个原理建议用演算纸自己计算一番，这里就不过多赘述了。这种状态转移的思路就是DP的核心。 状态转移方程动态规划中当前的状态往往依赖于前一阶段的状态和前一阶段的决策结果。例如我们知道了第i个阶段的状态Si以及决策Ui，那么第i+1阶段的状态Si+1也就确定了。所以解决动态规划问题的关键就是确定状态转移方程，一旦状态转移方程确定了，那么我们就可以根据方程式进行编码。 各种模型的状态转移方程汇总如下：1、最长公共子串假设两个字符串为str1和str2，它们的长度分别为n和m。d[i][j]表示str1中前i个字符与str2中前j个字符分别组成的两个前缀字符串的最长公共长度。这样就把长度为n的str1和长度为m的str2划分成长度为i和长度为j的子问题进行求解。状态转移方程如下： 1234dp[0][j] = 0; (0&lt;=j&lt;=m)dp[i][0] = 0; (0&lt;=i&lt;=n)dp[i][j] = dp[i-1][j-1] +1; (str1[i] == str2[j])dp[i][j] = 0; (str1[i] != str2[j]) 因为最长公共子串要求必须在原串中是连续的，所以一但某处出现不匹配的情况，此处的值就重置为0。 详细代码请看最长公共子串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;stdafx.h&quot;#include &lt;stdio.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100char str1[MAXSIZE];char str2[MAXSIZE];int dp[MAXSIZE][MAXSIZE];//'y'代表str1[i] = str2[j];'n'反之char path[MAXSIZE][MAXSIZE];void printComStr(int i, int j){ if (path[i][j] == 'n' || i == 0 || j == 0) return; if (path[i][j] == 'y') { printComStr(i - 1, j - 1); cout &lt;&lt; str1[i - 1]; }}int main(){ int n, m; int indexi, indexj; int ans = 0; cin &gt;&gt; str1 &gt;&gt; str2; n = strlen(str1); m = strlen(str2); for (int i = 0; i &lt;= n;i++) for (int j = 0; j &lt;= m; j++) { dp[i][j] = 0; } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (str1[i - 1] == str2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; path[i][j] = 'y'; } else { dp[i][j] = 0; path[i][j] = 'n'; } } for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (ans &lt; dp[i][j]) { ans = dp[i][j]; indexi = i; indexj = j; } } cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; indexi &lt;&lt; ' ' &lt;&lt; indexj &lt;&lt; endl; printComStr(indexi, indexj);} 2、最长公共子序列区分一下，最长公共子序列不同于最长公共子串，序列是保持子序列字符串的下标在str1和str2中的下标顺序是递增的，该字符串在原串中并不一定是连续的。同样的我们可以假设dp[i][j]表示为字符串str1的前i个字符和字符串str2的前j个字符的最长公共子序列的长度。状态转移方程如下： 1234dp[0][j] = 0; (0&lt;=j&lt;=m)dp[i][0] = 0; (0&lt;=i&lt;=n)dp[i][j] = dp[i-1][j-1] +1; (str1[i-1] == str2[j-1])dp[i][j] = max{dp[i][j-1],dp[i-1][j]}; (str1[i-1] != str2[j-1]) 详细代码请看最长公共子序列。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define MAXSIZE 101char str1[MAXSIZE];char str2[MAXSIZE];//'l'表示dp[i][j] = dp[i][j] = dp[i - 1][j];//‘q’表示dp[i][j] = dp[i][j] = dp[i - 1][j];//'u'表示dp[i][j] = dp[i][j - 1];char path[MAXSIZE][MAXSIZE];int dp[MAXSIZE][MAXSIZE];void printLCS(int i, int j){ if (i == 0 || j == 0) return; if (path[i][j] == 'q') { printLCS(i - 1, j - 1); cout &lt;&lt; str1[i-1] &lt;&lt; ' '; } else if (path[i][j] == 'u') printLCS(i - 1, j); else printLCS(i, j - 1); } int main(){ int n, m; cin &gt;&gt; str1 &gt;&gt; str2; n = strlen(str1); m = strlen(str2); //初始化 for (int i = 0; i &lt; n;i++) for (int j = 0; j &lt; m; j++) dp[i][j] = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) { if (str1[i - 1] == str2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; path[i][j] = 'q'; } else { if (dp[i - 1][j] &gt;= dp[i][j - 1]) { dp[i][j] = dp[i - 1][j]; path[i][j] = 'u'; } else { dp[i][j] = dp[i][j - 1]; path[i][j] = 'l'; } } } cout &lt;&lt; dp[n][m] &lt;&lt; endl; printLCS(n, m); return 0;} 3、最长递增子序列（最长递减子序列）因为两者的思路都是一样的，所以只给出最长递增子序列的状态转移方程。假设有序列{a1,a2,…,an}，我们求其最长递增子序列长度。按照递推求解的思想，我们用F[i]代表若递增子序列以ai结束时它的最长长度。当 i 较小，我们容易直接得出其值，如 F[1] = 1。那么，如何由已经求得的 F[i]值推得后面的值呢？假设，F[1]到F[x-1]的值都已经确定，注意到，以ax 结尾的递增子序列，除了长度为1的情况，其它情况中，ax都是紧跟在一个由 ai(i &lt; x)组成递增子序列之后。要求以ax结尾的最长递增子序列长度，我们依次比较 ax 与其之前所有的 ai(i &lt; x)， 若ai小于 ax，则说明ax可以跟在以ai结尾的递增子序列之后，形成一个新的递 增子序列。又因为以ai结尾的递增子序列最长长度已经求得，那么在这种情况下，由以 ai 结尾的最长递增子序列再加上 ax 得到的新的序列，其长度也可以确定，取所有这些长度的最大值，我们即能得到 F[x]的值。特殊的，当没有ai(i &lt; x)小 于ax， 那么以 ax 结尾的递增子序列最长长度为1。 即F[x] = max{1,F[i]+1|ai&lt;ax &amp;&amp; i&lt;x}。 详细代码请看最长递增子序列。 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;const int MAXSIZE = 10;const int MIN = 0;int arr[] = { 1, 4, 3, 2, 6, 5 };int F[MAXSIZE];int main(){ int maxLen = MIN; memset(F, 0, MAXSIZE); F[0] = 1; for (int i = 1; i &lt; 6; i++) { for (int j = 0; j &lt; i; j++) { if (arr[i] &gt; arr[j] &amp;&amp; maxLen &lt; F[j]) { maxLen = F[j]; } } F[i] = maxLen + 1; } for (int k = 0; k &lt; 6; k++) cout &lt;&lt; F[k] &lt;&lt; ' '; cout &lt;&lt; endl;} 4、最大子序列和的问题假设有序列{a1,a2,…,an}，求子序列的和最大问题，我们用dp[i]表示以ai结尾的子序列的最大和。 12345dp[1] = a1; (a1&gt;=0 &amp;&amp; i == 1)dp[i] = dp[i-1]+ai; (ai&gt;=0 &amp;&amp; i&gt;=2)dp[i] = 0; (dp[i-1] + ai &lt;=0 &amp;&amp; i&gt;=2) 详细代码请看最大子序列的和。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;#define MAXSIZE 100int a[MAXSIZE];int dp[MAXSIZE];int max = 0;int main(){ int n; cin &gt;&gt; n; memset(dp, 0, MAXSIZE); for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) { if (dp[i-1] + a[i] &gt; 0) { dp[i] = dp[i - 1] + a[i]; } else { dp[i] = 0; } if (max &lt; dp[i]) max = dp[i]; } cout &lt;&lt; max &lt;&lt; endl; return 0;} 5、数塔问题（动态搜索）给定一个数组data[n][m]构成一个数塔求从最上面走到最低端经过的路径和最大。可以假设dp[i][j]表示走到第i行第j列位置处的最大值，那么可以推出状态转移方程： 1dp[i][j] = max{dp[i-1][j-1],dp[i-1][j]} + data[i][j]; 12345for(i=n-1;i&gt;=1;i--){ for(j=1;j&lt;=i;j++){ dp[i][j]=max{dp[i-1][j-1],dp[i-1][j]}+s[i][j] }} 6、（01）背包问题这是一个经典的动态规划问题，另外在贪心算法里也有背包问题，至于二者的区别在此就不做介绍了。 假设有N件物品和一个容量为V的背包。第i件物品的体积是v[i]，价值是c[i]，将哪些物品装入背包可使价值总和最大？ 每一种物品都有两种可能即放入背包或者不放入背包。可以用dp[i][j]表示第i件物品放入容量为j的背包所得的最大价值，则状态转移方程可以推出如下： 1dp[i][j]=max{dp[i-1][j-v[i]]+c[i],dp[i-1][j]}; 1234567891011for (int i = 1;i &lt;= N;i++) //枚举物品 { for (int j = 0;j &lt;= V;j++) //枚举背包容量 { f[i][j] = f[i - 1][j]; if (j &gt;= v[i]) { f[i][j] = Max(f[i - 1][j],f[i - 1][j - v[i]] + c[i]); } } } 说明 12345678901背包问题与背包问题的区别在于，01背包，物品的选择只有两种一种是拿，另一种是不拿，而背包问题在于，物品可以只取一部分。所以01背包问题不能用贪心算法解决。以dp[i][j]表示用i种物品，重量为j表示所取得的价值。对于第i种物品，如果第i种物品重量大于j，就证明第i种物品肯定不能取，这时的dp[i][j]=dp[i-1][j]如果第i种物品重量小于j，那就会出现两种情况，采用i的话，物品价值dp[i][j]=采用前面的i-1种物品，所占用的重量为j-i.getweight,所产生的价值+第i 种物品的价值，。如果不采用i，价值为dp[i-1][j]。换成数学表达式就是dp[i][j]=Math.max(dp[i-1][j-weight]+value,dp[i-1][j]);比如当i=5,j=10时，dp[5][10]就代表了所取得的最大价值。到这里我们就完成了任务的一半，接下为我们要寻找到底哪些物品放入了背包，从前面的表达式我们可以发现，当dp[i][j]=dp[i-1][j-weight]时，这时为i的物品就会放入背包，所以我们从结果，开始往回走，遇到这种情况，就说明有物品放入背包，然后物品数减1，重量减去为i的重量，继续，最后就能求出哪 些物品放入背包了。 JAVA代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Test { public static void main(String[] args) { int allweight=12; //总价值 int num=8; //物品 bao[] baos=new bao[num+1]; baos[1]=new bao(2, 13); baos[2]=new bao(1, 10); baos[3]=new bao(3, 24); baos[4]=new bao(2, 15); baos[5]=new bao(4, 28); baos[6]=new bao(5, 33); baos[7]=new bao(3, 20); baos[8]=new bao(1, 8); int[][] dp=new int[num+1][allweight+1]; //构成动态规划表 for(int i=0;i&lt;=num;i++) { for(int j=0;j&lt;=allweight;j++) { if(i==0||j==0) { dp[i][j]=0; }else { if (j&lt;baos[i].getWeight()) { dp[i][j]=dp[i-1][j]; }else { int value=baos[i].getValue(); int weight=baos[i].getWeight(); dp[i][j]=Math.max(dp[i-1][j-weight]+value,dp[i-1][j]); } } System.out.println(&quot;dp&quot;+&quot;[&quot;+i+&quot;]&quot;+&quot;[&quot;+j+&quot;]&quot;+dp[i][j]); } } int m=num; int n=allweight; int all=dp[m][n]; //寻找哪些物品放入背包 while(all&gt;=0) { if (m&gt;0&amp;&amp;dp[m][n]==dp[m-1][n]) { m=m-1; }else { System.out.println(baos[m]+&quot;加入背包&quot;); m=m-1; if (m==0) { return; }else { n=n-baos[m].getWeight(); all=all-baos[m].getWeight(); } } } }} 可以参照动态规划 - 0-1背包问题的算法优化、动态规划-完全背包问题、动态规划-多重背包问题、01背包问题 7、矩阵连乘（矩阵链问题）-参考《算法导论》例如矩阵链&lt;A1,A2,A3&gt;,它们的维数分别为10100,1005,550，那么如果顺序相乘即((A1A2)A3)，共需101005 + 10550 = 7500次乘法，如果按照(A1(A2A3))顺序相乘，却需做100550 + 10100*50 = 75000次乘法。两者之间相差了10倍，所以说矩阵链的相乘顺序也决定了计算量的大小。 我们用利用动态规划的方式(dp[i][j]表示第i个矩阵至第j个矩阵这段的最优解,还有对于两个矩阵A(i,j)B(j,k)则需要ij*k次乘法)，推出状态转移方程： 123dp[i][j] = 0; (i ==j，表示只有一个矩阵，计算次数为0)dp[i][j] = min{dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j]}; (i&lt;j &amp;&amp; i&lt;=k&lt;j) dp[1][n]即为最终求解. 123456789101112131415161718192021222324252627282930313233343536#define MAXSIZE 100int dp[MAXSIZE][MAXSIZE];//存储最小的就算次数int s[MAXSIZE][MAXSIZE];//存储断点，用在输出上面int i, j, tmp；for (int l = 2; l &lt;= n; l++){//j-i的长度,由于长度为1是相同的矩阵那么为0不用计算 for (i = 1; i &lt;= n - l + 1; i++){//由于j-i =l - 1 , 那么j的最大值为n，所以i上限为 n - l+1; j = i + l - 1;//由于j-i = l - 1 , 那么j = l+i-1 dp[i][j] = dp[i + 1][j] + r[i] * c[i] * c[j];//初始化，就是k = i； s[i][j] = i; for (k = i + 1; k &lt; j; k++){//循环枚举k i &lt; k &lt; j tmp = dp[i][k] + dp[k + 1][j] + r[i] * c[k] * c[j]; if (dp[i][j] &gt; tmp){ dp[i][j] = tmp;//更新为最小值 s[i][j] = k; } } }}//递归调用输出void output(int i, int j){ if (i == j){ printf(&quot;A%d&quot;, i);//当两个相等的时候就不用继续递归就输出A return;//返回上一层 } else{ printf(&quot;(&quot;); output(i, s[i][j]); printf(&quot; x &quot;); output(s[i][j] + 1, j); printf(&quot;)&quot;); }} 总结太难了，没事多来看看示例希望早日彻底吃透！ 参考文章:参考链接1参考链接2","link":"/2019/12/14/algorithm/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92DP%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"title":"算法成长之路leetcode15-16","text":"15. 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example123456789Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package algorithm;import java.util.*;/** * 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ， * 使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 * * 注意：答案中不可以包含重复的三元组。 * * 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， * * 满足要求的三元组集合为： * [ * [-1, 0, 1], * [-1, -1, 2] * ] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/3sum * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode15 { // ❌错解 public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); Set&lt;String&gt; ids = new HashSet&lt;&gt;(); for (int i = 0; i &lt; nums.length - 2; i++) { for (int j = i+1; j &lt; nums.length-1; j++) { for (int k = j+1; k &lt; nums.length; k++) { if(nums[i]+nums[j]+nums[k] == 0){ String i2 = nums[i] + &quot;&quot;+nums[j]+nums[k]; System.out.println(nums[i]+&quot;,&quot;+nums[j]+&quot;,&quot;+nums[k]+&quot;=&quot;+i2); if(!ids.contains(i2)){ ids.add(i2); res.add(Arrays.asList(nums[i],nums[j],nums[k])); } } } } } return res; } /** * 思路 * 标签：数组遍历 * 首先对数组进行排序，排序后固定一个数 nums[i]nums[i]，再使用左右指针指向 nums[i]nums[i]后面的两端，数字分别为 nums[L]nums[L] 和 nums[R]nums[R]，计算三个数的和 sumsum 判断是否满足为 00，满足则添加进结果集 * 如果 nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环 * 如果 nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过 * 当 sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1] 则会导致结果重复，应该跳过，L++L++ * 当 sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1] 则会导致结果重复，应该跳过，R--R−− * 时间复杂度：O(n^2)，n 为数组长度 * * 作者：guanpengchn * 链接：https://leetcode-cn.com/problems/3sum/solution/hua-jie-suan-fa-15-san-shu-zhi-he-by-guanpengchn/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param nums * @return */ public static List&lt;List&lt;Integer&gt;&gt; threeSum1(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int len = nums.length; if (nums == null || len &lt; 3) return ans; Arrays.sort(nums); // 排序 for (int i = 0; i &lt; len; i++) { if (nums[i] &gt; 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; // 去重 int L = i + 1; int R = len - 1; while (L &lt; R) { int sum = nums[i] + nums[L] + nums[R]; if (sum == 0) { ans.add(Arrays.asList(nums[i], nums[L], nums[R])); // 此时nums[L] == nums[L + 1] 会重复，继续跳过一个 while (L &lt; R &amp;&amp; nums[L] == nums[L + 1]) L++; // 去重 while (L &lt; R &amp;&amp; nums[R] == nums[R - 1]) R--; // 去重 L++; R--; } else if (sum &lt; 0) L++; else if (sum &gt; 0) R--; } } return ans; } public static void main(String[] args) { System.out.println(threeSum(new int[]{-4, -2, -2, -2, 0, 1, 2, 2, 2, 3, 3, 4, 4, 6, 6})); }} 16. 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example123456Example:Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). JAVA题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package algorithm;import java.util.Arrays;/** * 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数， * 使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 * * 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. * * 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/3sum-closest * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode16 { // 想到的思路，找出所有的组合以及它们的sum，然后排好序二分法查找sum中最接近的 public int threeSumClosest(int[] nums, int target) { return 0; } /** * 思路 * 标签：排序和双指针 * 本题目因为要计算三个数，如果靠暴力枚举的话时间复杂度会到 O(n^3)，需要降低时间复杂度 * 首先进行数组排序，时间复杂度 O(nlogn)O(nlogn) * 在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 nums[i] * 再使用前指针指向 start = i + 1 处，后指针指向 end = nums.length - 1 处，也就是结尾处 * 根据 sum = nums[i] + nums[start] + nums[end] 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans * 同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end--，如果 sum &lt; target 则 start++，如果 sum == target 则说明距离为 0 直接返回结果 * 整个遍历过程，固定值为 n 次，双指针为 n 次，时间复杂度为 O(n^2) * 总时间复杂度：O(nlogn) + O(n^2) = O(n^2) * * 作者：guanpengchn * 链接：https://leetcode-cn.com/problems/3sum-closest/solution/hua-jie-suan-fa-16-zui-jie-jin-de-san-shu-zhi-he-b/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param nums * @param target * @return */ public int threeSumClosest1(int[] nums, int target) { Arrays.sort(nums); int ans = nums[0] + nums[1] + nums[2]; for(int i=0;i&lt;nums.length;i++) { int start = i+1, end = nums.length - 1; while(start &lt; end) { int sum = nums[start] + nums[end] + nums[i]; // 结果差值更小时，取更小的 if(Math.abs(target - sum) &lt; Math.abs(target - ans)) ans = sum; // 结果大于目标，右边的左移 if(sum &gt; target) end--; else if(sum &lt; target) start++; else // 相等时直接返回结果 return ans; } } return ans; }}","link":"/2020/01/01/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode15-16/"},{"title":"算法成长之路leetcode17-18","text":"17. Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example12345678Example:Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].Note:Although the above answer is in lexicographical order, your answer could be in any order you want. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111package algorithm;import java.util.*;/** * 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 * * 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 * 示例: 输入：&quot;23&quot; 输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. */public class Leetcode17 { public static List&lt;String&gt; letterCombinations(String digits) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); String[] indexToStr = new String[]{&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;}; if (digits == null || &quot;&quot;.equals(digits)) return res; else if(digits.length() == 1) { char[] chars = indexToStr[Integer.parseInt(digits)].toCharArray(); for (int i = 0; i &lt; chars.length; i++) { res.add(new String(new char[]{chars[i]})); } } char[] charArray = digits.toCharArray(); char[] i0Char = indexToStr[(int) charArray[0] - (int) ('0')].toCharArray(); for (int i = 1; i &lt; charArray.length; i++) { for (int i1 = 0; i1 &lt; i0Char.length; i1++) { char[] chars1 = indexToStr[(int) charArray[i] - (int) ('0')].toCharArray(); for (int i2 = 0; i2 &lt; chars1.length; i2++) { res.add(new String(new char[]{i0Char[i1], chars1[i2]})); } } } return res; } Map&lt;String, String&gt; phone = new HashMap&lt;String, String&gt;() {{ put(&quot;2&quot;, &quot;abc&quot;); put(&quot;3&quot;, &quot;def&quot;); put(&quot;4&quot;, &quot;ghi&quot;); put(&quot;5&quot;, &quot;jkl&quot;); put(&quot;6&quot;, &quot;mno&quot;); put(&quot;7&quot;, &quot;pqrs&quot;); put(&quot;8&quot;, &quot;tuv&quot;); put(&quot;9&quot;, &quot;wxyz&quot;); }}; List&lt;String&gt; output = new ArrayList&lt;String&gt;(); public void backtrack(String combination, String next_digits) { // if there is no more digits to check if (next_digits.length() == 0) { // the combination is done output.add(combination); } // if there are still digits to check else { // iterate over all letters which map // the next available digit String digit = next_digits.substring(0, 1); String letters = phone.get(digit); for (int i = 0; i &lt; letters.length(); i++) { String letter = phone.get(digit).substring(i, i + 1); // append the current letter to the combination // and proceed to the next digits backtrack(combination + letter, next_digits.substring(1)); } } } /** * 方法：回溯 * 回溯是一种通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。 * * 给出如下回溯函数 backtrack(combination, next_digits) ，它将一个目前已经产生的组合 combination 和接下来准备要输入的数字 next_digits 作为参数。 * * 如果没有更多的数字需要被输入，那意味着当前的组合已经产生好了。 * 如果还有数字需要被输入： * 遍历下一个数字所对应的所有映射的字母。 * 将当前的字母添加到组合最后，也就是 combination = combination + letter 。 * 重复这个过程，输入剩下的数字： backtrack(combination + letter, next_digits[1:]) 。 * * 有动画图解 * 作者：LeetCode * 链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param digits * @return */ public List&lt;String&gt; letterCombinations1(String digits) { if (digits.length() != 0) backtrack(&quot;&quot;, digits); return output; } public static void main(String[] args) { System.out.println(letterCombinations(&quot;3&quot;)); System.out.println(new Leetcode17().letterCombinations1(&quot;234&quot;)); }} 18. 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example1234567891011Example:Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154package algorithm;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ， * 使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 * * 注意： * * 答案中不可以包含重复的四元组。 * * 示例： * * 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 * * 满足要求的四元组集合为： * [ * [-1, 0, 0, 1], * [-2, -1, 1, 2], * [-2, 0, 0, 2] * ] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/4sum * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode18 { /** * 思路： * * 四数之和与前面三数之和的思路几乎是一样的，嗝。（刚好前些天才写了三数之和的题解） * 如果前面的三数之和会做了的话，这里其实就是在前面的基础上多添加一个遍历的指针而已。 * 会做三数之和的可以不用看下面的了。。 * * 使用四个指针(a&lt;b&lt;c&lt;d)。固定最小的a和b在左边，c=b+1,d=_size-1 移动两个指针包夹求解。 * 保存使得nums[a]+nums[b]+nums[c]+nums[d]==target的解。偏大时d左移，偏小时c右移。c和d相 * 遇时，表示以当前的a和b为最小值的解已经全部求得。b++,进入下一轮循环b循环，当b循环结束后。 * a++，进入下一轮a循环。 即(a在最外层循环，里面嵌套b循环，再嵌套双指针c,d包夹求解)。 * 准备工作： * * 因为要使用双指针的方法，排序是必须要做der~。 时间复杂度O(NlogN). * * 作者：misakasagiri-2 * 链接：https://leetcode-cn.com/problems/4sum/solution/shuang-zhi-zhen-jie-fa-can-zhao-san-shu-zhi-he-ge-/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * @param nums * @param target * @return */ public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { /*定义一个返回值*/ List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); /*当数组为null或元素小于4个时，直接返回*/ if (nums == null || nums.length &lt; 4) { return result; } /*对数组进行从小到大排序*/ Arrays.sort(nums); System.out.println(&quot;-4,-1,-1,0,1,2&quot;); /*数组长度*/ int length = nums.length; /*定义4个指针k，i，j，h k从0开始遍历，i从k+1开始遍历，留下j和h，j指向i+1，h指向数组最大值*/ for (int k = 0; k &lt; length - 3; k++) { /*当k的值与前面的值相等时忽略*/ if (k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) { continue; } /*获取当前最小值，如果最小值比目标值大，说明后面越来越大的值根本没戏*/ int min1 = nums[k] + nums[k + 1] + nums[k + 2] + nums[k + 3]; if (min1 &gt; target) { break; } /*获取当前最大值，如果最大值比目标值小，说明后面越来越小的值根本没戏，忽略*/ int max1 = nums[k] + nums[length - 1] + nums[length - 2] + nums[length - 3]; if (max1 &lt; target) { continue; } /*第二层循环i，初始值指向k+1*/ for (int i = k + 1; i &lt; length - 2; i++) { /*当i的值与前面的值相等时忽略*/ if (i &gt; k + 1 &amp;&amp; nums[i] == nums[i - 1]) { continue; } /*定义指针j指向i+1*/ int j = i + 1; /*定义指针h指向数组末尾*/ int h = length - 1; /*获取当前最小值，如果最小值比目标值大，说明后面越来越大的值根本没戏，忽略*/ int min = nums[k] + nums[i] + nums[j] + nums[j + 1]; if (min &gt; target) { System.out.println(&quot;m,k=&quot;+k+&quot;,i=&quot;+i+&quot;,j=&quot;+j+&quot;,j+1=&quot;+(j+1)); break; // 此时直接滑动k,因为不管怎么滑动i,min 都会大于target } /*获取当前最大值，如果最大值比目标值小，说明后面越来越小的值根本没戏，忽略*/ int max = nums[k] + nums[i] + nums[h] + nums[h - 1]; if (max &lt; target) { System.out.println(&quot;ma,k=&quot;+k+&quot;,i=&quot;+i+&quot;,j=&quot;+j+&quot;,j+1=&quot;+(j+1)); continue; // 此时continue滑动i 值，nums[i] + nums[h] + nums[h - 1] 变大 ，整个max 会变大 } /** * -4,-1,-1,0,1,2 * ma,k=0,i=1,j=2,j+1=3 * m,k=1,i=3,j=4,j+1=5 * [[-4, 0, 1, 2], [-1, -1, 0, 1]] * * -4,-1,-1,0,1,2 * ma,k=0,i=1,j=2,j+1=3 * m,k=1,i=3,j=4,j+1=5 * [[-1, -1, 0, 1]] */ /*开始j指针和h指针的表演，计算当前和，如果等于目标值，j++并去重，h--并去重，当当前和大于目标值时h--，当当前和小于目标值时j++*/ while (j &lt; h) { int curr = nums[k] + nums[i] + nums[j] + nums[h]; if (curr == target) { result.add(Arrays.asList(nums[k], nums[i], nums[j], nums[h])); j++; while (j &lt; h &amp;&amp; nums[j] == nums[j - 1]) { j++; } h--; while (j &lt; h &amp;&amp; i &lt; h &amp;&amp; nums[h] == nums[h + 1]) { h--; } } else if (curr &gt; target) { h--; } else { j++; } } } } return result; } /* 作者：you-wei-wu 链接：https://leetcode-cn.com/problems/4sum/solution/ji-bai-9994de-yong-hu-you-dai-ma-you-zhu-shi-by-yo/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */ public static void main(String[] args) { System.out.println(new Leetcode18().fourSum(new int[]{-1,0,1,2,-1,-4},-1)); }}","link":"/2020/01/08/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode17-18/"},{"title":"算法成长之路leetcode19-20","text":"19. Remove Nth Node From End of ListGiven a linked list, remove the n-th node from the end of list and return its head. Example12345678910111213Example:Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.Note:Given n will always be valid.Follow up:Could you do this in one pass? JAVA题解方法一：两次遍历算法 思路 我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)(L−n+1) 个结点，其中 LL 是列表的长度。只要我们找到列表的长度 LL，这个问题就很容易解决。 算法 首先我们将添加一个哑结点作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 LL。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n)(L−n) 个结点那里。我们把第 (L - n)(L−n) 个结点的 next 指针重新链接至第 (L - n + 2)(L−n+2) 个结点，完成这个算法。 1234567891011121314151617181920212223242526272829/**给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。进阶：你能尝试使用一趟扫描实现吗？*/public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; int length = 0; ListNode first = head; while (first != null) { length++; first = first.next; } length -= n; first = dummy; while (length &gt; 0) { length--; first = first.next; } first.next = first.next.next; return dummy.next;} 方法二：一次遍历算法 算法 上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n+1n+1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 nn 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 nn 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。 12345678910111213141516171819202122public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode first = dummy; ListNode second = dummy; // Advances first pointer so that the gap between first and second is n nodes apart for (int i = 1; i &lt;= n + 1; i++) { first = first.next; } // Move first to the end, maintaining the gap while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummy.next;}作者：LeetCode链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-by-l/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 20. Valid ParenthesesGiven a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets.Open brackets must be closed in the correct order.Note that an empty string is also considered valid. Example123456789101112131415161718192021Example 1:Input: &quot;()&quot;Output: trueExample 2:Input: &quot;()[]{}&quot;Output: trueExample 3:Input: &quot;(]&quot;Output: falseExample 4:Input: &quot;([)]&quot;Output: falseExample 5:Input: &quot;{[]}&quot;Output: true JAVA题解Leetcode20.java >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package algorithm;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 * * 有效字符串需满足： * * 左括号必须用相同类型的右括号闭合。 * 左括号必须以正确的顺序闭合。 * 注意空字符串可被认为是有效字符串。 * * 示例 1: * * 输入: &quot;()&quot; * 输出: true * 示例 2: * * 输入: &quot;()[]{}&quot; * 输出: true * 示例 3: * * 输入: &quot;(]&quot; * 输出: false * 示例 4: * * 输入: &quot;([)]&quot; * 输出: false * 示例 5: * * 输入: &quot;{[]}&quot; * 输出: true * */public class Leetcode20 { // 类似栈的处理 public boolean isValid(String s) { if(s == null || s.equals(&quot;&quot;)){ return true; } // 奇数 if(s.length() % 2 != 0){ return false; } List&lt;Integer&gt; arr = new ArrayList&lt;&gt;(); Map&lt;Character, Integer&gt; cIn = new HashMap&lt;&gt;(); cIn.put('(', 1); cIn.put(')', -1); cIn.put('{', 2); cIn.put('}', -2); cIn.put('[', 3); cIn.put(']', -3); char[] chars = s.toCharArray(); arr.add(cIn.get(chars[0])); for (int i = 1; i &lt; chars.length; i++) { // 相等则移除 int latestIndex = arr.size() - 1; if (latestIndex &gt;= 0 &amp;&amp; arr.get(latestIndex) == -cIn.get(chars[i])) { arr.remove(latestIndex); } else { arr.add(cIn.get(chars[i])); } } if (arr.size() &gt; 0) { return false; } else { return true; } } public static void main(String[] args) { System.out.println(new Leetcode20().isValid(&quot;([])[]&quot;)); }}// 栈的处理class Solution { public boolean isValid(String s) { if(s.isEmpty()) return true; Stack&lt;Character&gt; stack=new Stack&lt;Character&gt;(); for(char c:s.toCharArray()){ if(c=='(') stack.push(')'); else if(c=='{') stack.push('}'); else if(c=='[') stack.push(']'); else if(stack.empty()||c!=stack.pop()) return false; } if(stack.empty()) return true; return false; }}// 栈 官方class Solution { // Hash table that takes care of the mappings. private HashMap&lt;Character, Character&gt; mappings; // Initialize hash map with mappings. This simply makes the code easier to read. public Solution() { this.mappings = new HashMap&lt;Character, Character&gt;(); this.mappings.put(')', '('); this.mappings.put('}', '{'); this.mappings.put(']', '['); } public boolean isValid(String s) { // Initialize a stack to be used in the algorithm. Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; s.length(); i++) { char c = s.charAt(i); // If the current character is a closing bracket. if (this.mappings.containsKey(c)) { // Get the top element of the stack. If the stack is empty, set a dummy value of '#' char topElement = stack.empty() ? '#' : stack.pop(); // If the mapping for this bracket doesn't match the stack's top element, return false. if (topElement != this.mappings.get(c)) { return false; } } else { // If it was an opening bracket, push to the stack. stack.push(c); } } // If the stack still contains elements, then it is an invalid expression. return stack.isEmpty(); }}","link":"/2020/01/19/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode19-20/"},{"title":"算法成长之路leetcode21-22","text":"21. Merge Two Sorted ListsMerge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example:12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 JAVA题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package algorithm.c3;/** * 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 * * 示例： * * 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 * 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode21 { // 错解 public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode l = new ListNode(0); ListNode cur = l; while (l1.next != null || l2.next != null){ if (l1.next == null) { cur.next = l2; } else if (l2.next == null) { cur.next = l1; }else { if(l1.val &gt; l2.val){ cur.next= l2; l2 = l2.next; }else if(l1.val == l2.val){ cur.next= l2; cur.next.next = l1; l1 = l1.next; l2 = l2.next; }else{ cur.next = l1; l1 = l1.next; } } cur = cur.next; } return l.next; } public ListNode mergeTwoLists1(ListNode l1, ListNode l2) { // maintain an unchanging reference to node ahead of the return node. ListNode prehead = new ListNode(-1); ListNode prev = prehead; while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt;= l2.val) { prev.next = l1; l1 = l1.next; } else { prev.next = l2; l2 = l2.next; } prev = prev.next; } // exactly one of l1 and l2 can be non-null at this point, so connect // the non-null list to the end of the merged list. prev.next = l1 == null ? l2 : l1; return prehead.next; } // 递归 public ListNode mergeTwoLists2(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.val &lt; l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } } public static void main(String[] args) { ListNode l1 = new ListNode(1); l1.next = new ListNode(2); l1.next.next = new ListNode(4); ListNode l2 = new ListNode(1); l2.next = new ListNode(1); l2.next.next = new ListNode(3); System.out.println(new Leetcode21().mergeTwoLists1(l1,l2)); } public static class ListNode { int val; ListNode next; ListNode(int x) { val = x; } }} 22. Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example:123456789For example, given n = 3, a solution set is:[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] JAVA题解：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package algorithm.c3;import java.util.LinkedList;import java.util.List;/** * 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 * * 例如，给出 n = 3，生成结果为： * * [ * &quot;((()))&quot;, * &quot;(()())&quot;, * &quot;(())()&quot;, * &quot;()(())&quot;, * &quot;()()()&quot; * ] * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/generate-parentheses * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */public class Leetcode22 { /** * * 在此题中，动态规划的思想类似于数学归纳法，当知道所有 i&lt;n 的情况时，我们可以通过某种算法算出 i=n 的情况。 * 本题最核心的思想是，考虑 i=n 时相比 n-1 组括号增加的那一组括号的位置。 * * 思路： * 当我们清楚所有 i&lt;n 时括号的可能生成排列后，对与 i=n 的情况，我们考虑整个括号排列中最左边的括号。 * 它一定是一个左括号，那么它可以和它对应的右括号组成一组完整的括号 &quot;( )&quot;，我们认为这一组是相比 n-1 增加进来的括号。 * * 那么，剩下 n-1 组括号有可能在哪呢？ * * 【这里是重点，请着重理解】 * * 剩下的括号要么在这一组新增的括号内部，要么在这一组新增括号的外部（右侧）。 * * 既然知道了 i&lt;n 的情况，那我们就可以对所有情况进行遍历： * * &quot;(&quot; + 【i=p时所有括号的排列组合】 + &quot;)&quot; + 【i=q时所有括号的排列组合】 * * 其中 p + q = n-1，且 p q 均为非负整数。 * * 事实上，当上述 p 从 0 取到 n-1，q 从 n-1 取到 0 后，所有情况就遍历完了。 * * 注：上述遍历是没有重复情况出现的，即当 (p1,q1)≠(p2,q2) 时，按上述方式取的括号组合一定不同。 * * 作者：yuyu-13 * 链接：https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * * 简单来说，在求N个括号的排列组合时，把第N种情况（也就是N个括号排列组合）视为单独拿一个括号E出来， * 剩下的N-1个括号分为两部分，P个括号和Q个括号，P+Q=N-1，然后这两部分分别处于括号E内和括号E的右边， * 各自进行括号的排列组合。由于我们是一步步计算得到N个括号的情况的，所以小于等于N-1个括号的排列组合方式我们是已知的（ * 用合适的数据结构存储，方便后续调用，且在存储时可利用特定数据结构实现题目某些要求，如排序，去重等）， * 且P+Q=N-1，P和Q是小于等于N-1的，所以我们能直接得到P个和Q个括号的情况，进而得到N个括号的结果！ * * 楼主的算法思想很巧妙，赞一个~这个算法主要的基点就是将排列组合的情况分为了括号内和括号外这两种情况， * 且仅存在两种情况！至于为什么，原因在于楼主的算法的前提是单独拿出来的括号E的左边在N个括号所有排列组合情况中都是处于最左边， * 所以不存在括号位于括号E的左边的情况。因此，N-1个括号（拿出了括号E）仅可能分布于括号E内和括号E外，分为两种子情况讨论！ * 这种思想还可以应用于其他类似的题的求解中，即怎样合理高效的利用前面步骤的计算结果得出当前步骤结果，从而得出最终结果。 * * @param n * @return */ public List&lt;String&gt; generateParenthesis(int n) { LinkedList&lt;LinkedList&lt;String&gt;&gt; result = new LinkedList&lt;LinkedList&lt;String&gt;&gt;(); if (n == 0) return result.get(0); LinkedList&lt;String&gt; list0 = new LinkedList&lt;String&gt;(); list0.add(&quot;&quot;); result.add(list0); LinkedList&lt;String&gt; list1 = new LinkedList&lt;String&gt;(); list1.add(&quot;()&quot;); result.add(list1); for (int i = 2; i &lt;= n; i++) { LinkedList&lt;String&gt; temp = new LinkedList&lt;String&gt;(); for (int j = 0; j &lt; i; j++) { List&lt;String&gt; str1 = result.get(j); List&lt;String&gt; str2 = result.get(i - 1 - j); for (String s1 : str1) { for (String s2 : str2) { String el = &quot;(&quot; + s1 + &quot;)&quot; + s2; temp.add(el); } } } result.add(temp); } return result.get(n); }}","link":"/2020/02/10/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode21-22/"},{"title":"算法成长之路leetcode5-6","text":"5. Longest Palindromic SubstringGiven a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example12345678Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Example 2:Input: &quot;cbbd&quot;Output: &quot;bb&quot; JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package algorithm;public class Leetcode5 { public static void main(String[] args) { System.out.println(longestPalindrome(&quot;abbaabb&quot;)); } /** * 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 * * 示例 1： * * 输入: &quot;babad&quot; * 输出: &quot;bab&quot; * 注意: &quot;aba&quot; 也是一个有效答案。 * 示例 2： * * 输入: &quot;cbbd&quot; * 输出: &quot;bb&quot; * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/longest-palindromic-substring * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ /** * 终于看懂了这个中心向两边扩张算法是什么意思了。 * 先来解释一下为什么中心是2n-1而不是n 比如有字符串abcba，这时回文子串是abcda， * 中心是c；又有字符串adccda，这时回文子串是adccda，中心是cc。 由此可见中心点既有可能是一个字符， * 也有可能是两个字符，当中心为一个字符的时候有n个中心， * 当中心为两个字符的时候有n-1个中心，所以一共有2n-1个中心。 * 然后for循环开始从左到右遍历，为什么会有两次expandAroundCenter，一次是i和i本身，一次是i和i+1， * 这就是上面说到的一个中心与两个中心。 而后会去判断这两种情况下谁的回文子串最长，并标记出这个子串在原字符串中的定位，即start和end。 * * @param s * @return */ public static String longestPalindrome(String s) { if (s == null || s.length() &lt; 1) return &quot;&quot;; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) { // 一个数向两边扩张 int len1 = expandAroundCenter(s, i, i); // 两个数向两边扩张 int len2 = expandAroundCenter(s, i, i + 1); // 取最长的回文 int len = Math.max(len1, len2); // 判读此时长度和原来的最长度 if (len &gt; end - start) { // 求最长回文开始位置 start = i - (len - 1) / 2; // 求最长回文结束位置 end = i + len / 2; } } // 截取最长回文 return s.substring(start, end + 1); } /** * 向两边向两边扩张求长度 * * @param s * @param left * @param right * @return */ private static int expandAroundCenter(String s, int left, int right) { // 定位中心位置 int L = left, R = right; // 判读中间位置是否相等，以及两边扩张是否相等 while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) { // 向左扩张一位 L--; // 向右扩张一位 R++; } // 回文的长度 如 aba 时,当 b = 1时，一个中心点进来,L = 1,R = 1,此时满足循环，L=0,R=2,此时也满足 // 循环，L = -1,R=3,此时循环结束，长度为3 = 3 -（-1） -1 return R - L - 1; }} 6. ZigZag ConversionThe string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility) P A H NA P L S I I GY I RAnd then read line by line: “PAHNAPLSIIGYIR” Write the code that will take a string and make this conversion given a number of rows: string convert(string s, int numRows); Example12345678910111213Example 1:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot;Example 2:Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I JAVA题解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package algorithm;import java.util.ArrayList;import java.util.List;public class Leetcode6 { /** * 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 * &lt;p&gt; * 比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下： * &lt;p&gt; * L C I R * E T O E S I I G * E D H N * 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 * &lt;p&gt; * 请你实现这个将字符串进行指定行数变换的函数： * &lt;p&gt; * string convert(string s, int numRows); * 示例 1: * &lt;p&gt; * 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3 * 输出: &quot;LCIRETOESIIGEDHN&quot; * 示例 2: * &lt;p&gt; * 输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4 * 输出: &quot;LDREOEIIECIHNTSG&quot; * 解释: * &lt;p&gt; * L D R * E O E I I * E C I H N * T S G * &lt;p&gt; * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/zigzag-conversion * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ public String convert(String s, int numRows) { if (numRows == 1) return s; List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) // 确定有多少行，每一行放一个待填充的字符串 rows.add(new StringBuilder()); // 当前行 int curRow = 0; // 上移或下移 false上移 boolean goingDown = false; for (char c : s.toCharArray()) { // 挨着放字符到对应的行 rows.get(curRow).append(c); // 判断是否下移，当第一行和最后一行的时候转向 if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; // 下移行数+1，上移行数-1 curRow += goingDown ? 1 : -1; } // 存最终结果 StringBuilder ret = new StringBuilder(); // 遍历每行，进行连接 for (StringBuilder row : rows) ret.append(row); return ret.toString(); } public static void main(String[] args) { Leetcode6 l = new Leetcode6(); System.out.println(l.convert(&quot;weweqw&quot;, 3)); }}","link":"/2019/12/05/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode5-6/"},{"title":"算法成长之路leetcode7-8","text":"7. Reverse IntegerGiven a 32-bit signed integer, reverse digits of an integer. Example1234567891011121314Example 1:Input: 123Output: 321Example 2:Input: -123Output: -321Example 3:Input: 120Output: 21 Note:Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package algorithm;public class Leetcode7 { /** * 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 * * 示例 1: * * 输入: 123 * 输出: 321 * 示例 2: * * 输入: -123 * 输出: -321 * 示例 3: * * 输入: 120 * 输出: 21 * 注意: * * 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/reverse-integer * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ public int reverse(int x) { if (x &gt; Integer.MAX_VALUE || x &lt; Integer.MIN_VALUE) { return 0; } boolean isNe = x &lt; 0 ? true : false; x = Math.abs(x); // 取绝对值时越界了，直接返回0 if (isNe &amp;&amp; x &lt; 0) { return 0; } StringBuilder sb = new StringBuilder(); long m = 10; long base = 1; while (true) { base = m * base; long re = x % base; if (base == 10) { sb.append(re); } else { sb.append((re * m) / base); } if (x &lt; base) { break; } } Long res; if (isNe) { res = 0 - Long.parseLong(sb.toString()); } else { res = Long.parseLong(sb.toString()); } if (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE) { return 0; } else { return res.intValue(); } } public int reverse1(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; // Integer.MAX_VALUE = 2147483647,因为后面 rev = rev * 10 + pop，所以rev &gt;Integer.MAX_VALUE 溢出 // rev == Integer.MAX_VALUE / 10 时，Integer.MAX_VALUE / 10 = 2147483640,so,pop &gt; 7时溢出 if (rev &gt; Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) return 0; // Integer.MIN_VALUE = -2147483648 // 同理如上 if (rev &lt; Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) return 0; rev = rev * 10 + pop; } return rev; } public static void main(String[] args) { System.out.println(Integer.MAX_VALUE);// System.out.println(reverse1(123)); }} 8. String to Integer (atoi)Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note: Only the space character ‘ ‘ is considered as whitespace character.Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned. Example12345678910111213141516171819202122232425262728Example 1:Input: &quot;42&quot;Output: 42Example 2:Input: &quot; -42&quot;Output: -42Explanation: The first non-whitespace character is '-', which is the minus sign. Then take as many numerical digits as possible, which gets 42.Example 3:Input: &quot;4193 with words&quot;Output: 4193Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.Example 4:Input: &quot;words and 987&quot;Output: 0Explanation: The first non-whitespace character is 'w', which is not a numerical digit or a +/- sign. Therefore no valid conversion could be performed.Example 5:Input: &quot;-91283472332&quot;Output: -2147483648Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer. Thefore INT_MIN (−2^31) is returned. JAVA题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package algorithm;public class Leetcode8 { /** * *请你来实现一个 atoi 函数，使其能将字符串转换成整数。 * * 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 * * 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 * * 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 * * 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 * * 在任何情况下，若函数不能进行有效的转换时，请返回 0。 * * 说明： * * 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 * * 示例 1: * * 输入: &quot;42&quot; * 输出: 42 * 示例 2: * * 输入: &quot; -42&quot; * 输出: -42 * 解释: 第一个非空白字符为 '-', 它是一个负号。 * 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 * 示例 3: * * 输入: &quot;4193 with words&quot; * 输出: 4193 * 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 * 示例 4: * * 输入: &quot;words and 987&quot; * 输出: 0 * 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 * 因此无法执行有效的转换。 * 示例 5: * * 输入: &quot;-91283472332&quot; * 输出: -2147483648 * 解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 * 因此返回 INT_MIN (−2^31) 。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/string-to-integer-atoi * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 */ public static int myAtoi(String str) { StringBuilder st = new StringBuilder(); for (int i = 0; i &lt; str.length(); i++) { char c = str.charAt(i); if (c == '-') { if (st.length() &gt; 0) { break; } st.append(c); } else if (c == '+') { if (st.length() &gt; 0) { break; } st.append(c); } else if (c == ' ') { if (st.length() &gt; 0) { break; } else { continue; } } else if (c &gt;= 48 &amp;&amp; c &lt;= 57) { st.append(c); } else { break; } if (st.length() &gt; 1) { if (Long.parseLong(st.toString()) &gt; Integer.MAX_VALUE) { return Integer.MAX_VALUE; } if (Long.parseLong(st.toString()) &lt; Integer.MIN_VALUE) { return Integer.MIN_VALUE; } } } if (st.length() == 0) { return 0; } if (st.toString().equals(&quot;-&quot;) || st.toString().equals(&quot;+&quot;)) { return 0; } return Long.valueOf(st.toString()).intValue(); } public int myAtoi1(String str) { if (str.isEmpty()) return 0; char[] mychar = str.toCharArray(); long ans = 0; int index = 0, flag = 1, n = str.length(); //排除字符串开头的空格元素 while (index &lt; n &amp;&amp; mychar[index] == ' ') { index++; } //排除空格后判断首字符是+还是-还是都不是 if (index &lt; n &amp;&amp; mychar[index] == '+') { index++; } else if (index &lt; n &amp;&amp; mychar[index] == '-') { index++; flag = -1; } //重点：只管是数字的时候，其余取0 while (index &lt; n &amp;&amp; (mychar[index] &gt;= '0' &amp;&amp; mychar[index] &lt;= '9')) { if (ans != (int) ans) {//超出int范围 return (flag == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE;//提前结束 } // 巧妙的加起来值来 如 111 ，第一个1时 ans = 0 * 10 +1,第二个1时 ans = 1*10 + 1 = 11,第三个1时， ans = 11*10 + 1 = 111; ans = ans * 10 + mychar[index++] - '0'; } // 强转long是否等于int 判断是否超界，机智 if (ans != (int) ans) { return (flag == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE; } return (int) (ans * flag); } public static void main(String[] args) { /** * &quot;42&quot; * &quot;----01&quot; * &quot;0-1&quot; * &quot;-5-&quot; */ System.out.println(myAtoi(&quot;0-1&quot;)); }}","link":"/2019/12/10/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode7-8/"},{"title":"算法成长之路leetcode9-10","text":"9. Palindrome NumberDetermine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example123456789101112131415161718Example 1:Input: 121Output: trueExample 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.Example 3:Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome.Follow up:Coud you solve it without converting the integer to a string? Java 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package algorithm;public class Leetcode9 { /** * 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 * * 示例 1: * * 输入: 121 * 输出: true * 示例 2: * * 输入: -121 * 输出: false * 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 * 示例 3: * * 输入: 10 * 输出: false * 解释: 从右向左读, 为 01 。因此它不是一个回文数。 * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/palindrome-number * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 * @param x * @return */ public static boolean isPalindrome(int x) { if (x &gt;= 0 &amp;&amp; x &lt; 10) { return true; } String source = x + &quot;&quot;; int length = source.length(); // mid中间位置1，mid1中间位置2 int mid, mid1; // 偶数 if (length % 2 == 0) { // 如 1221 偶数，中间位置分别为2，2 mid = length / 2 - 1; mid1 = mid + 1; } else { // 奇数时，212，中间位置分别是1，1 mid = length / 2; mid1 = mid; } // 确定中心位置向两边扩展是否相等，直到扩展完位置 while (mid &gt;= 0 &amp;&amp; source.charAt(mid) == source.charAt(mid1)) { mid = mid - 1; mid1 = mid1 + 1; } // 如果循环结束并且所有数都遍历完 if (mid == -1 &amp;&amp; mid1 == length) { return true; } else { return false; } } public static boolean isPalindrome1(int x) { // 特殊情况： // 如上所述，当 x &lt; 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) { return false; } // 一位一位反转的数 int revertedNumber = 0; // 如121 while (x &gt; revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; System.out.println(&quot;x=&quot; + x + &quot;,revertedNumber=&quot; + revertedNumber); } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber / 10; } public static void main(String[] args) { /** * -1 * 121 * 222 * 2222 * 1221 * -12 */ System.out.println(isPalindrome(1221)); System.out.println(isPalindrome1(121)); }} 10. Regular Expression MatchingGiven an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’. ‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like . or *. Example12345678910111213141516171819202122232425262728293031323334Example 1:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.Example 2:Input:s = &quot;aa&quot;p = &quot;a&quot;Output: trueExplanation: '' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.Example 3:Input:s = &quot;ab&quot;p = &quot;.&quot;Output: trueExplanation: &quot;.&quot; means &quot;zero or more (*) of any character (.)&quot;.Example 4:Input:s = &quot;aab&quot;p = &quot;cab&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches &quot;aab&quot;.Example 5:Input:s = &quot;mississippi&quot;p = &quot;misisp*.&quot;Output: false JAVA 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455package algorithm;public class Leetcode10 { /** * 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 * * '.' 匹配任意单个字符 * '*' 匹配零个或多个前面的那一个元素 * 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 * * 说明: * * s 可能为空，且只包含从 a-z 的小写字母。 * p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 * 示例 1: * * 输入: * s = &quot;aa&quot; * p = &quot;a&quot; * 输出: false * 解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 * 示例 2: * * 输入: * s = &quot;aa&quot; * p = &quot;a*&quot; * 输出: true * 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 &quot;aa&quot; 可被视为 'a' 重复了一次。 * 示例 3: * * 输入: * s = &quot;ab&quot; * p = &quot;.*&quot; * 输出: true * 解释: &quot;.*&quot; 表示可匹配零个或多个（'*'）任意字符（'.'）。 * 示例 4: * * 输入: * s = &quot;aab&quot; * p = &quot;c*a*b&quot; * 输出: true * 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 * 示例 5: * * 输入: * s = &quot;mississippi&quot; * p = &quot;mis*is*p*.&quot; * 输出: false * * 来源：力扣（LeetCode） * 链接：https://leetcode-cn.com/problems/regular-expression-matching * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 * * * * 如果模式串中有星号，它会出现在第二个位置， * 即pattern[1] 。这种情况下，我们可以直接忽略模式串中这一部分， * 或者删除匹配串的第一个字符，前提是它能够匹配模式串当前位置字符，即 pattern[0] 。 * 如果两种操作中有任何一种使得剩下的字符串能匹配，那么初始时，匹配串和模式串就可以被匹配。 * * @param text * @param pattern * @return */ public static boolean isMatch(String text, String pattern) { // 递归回溯 if (pattern.isEmpty()) return text.isEmpty(); boolean first_match = (!text.isEmpty() &amp;&amp; (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));// 判断第一个是否相等 System.out.println(&quot;t=&quot;+text+&quot;,p=&quot;+pattern+&quot;,firstM=&quot;+first_match); if (pattern.length() &gt;= 2 &amp;&amp; pattern.charAt(1) == '*'){ // 长度&gt;=2 并且p第二个是* System.out.println(&quot;if1&quot;); return (isMatch(text, pattern.substring(2)) || // 直接忽略模式串中这一部分 如t=abc,p=a*. 直接忽略 a* (first_match &amp;&amp; isMatch(text.substring(1), pattern))); // 删除匹配串的第一个字符 } else { System.out.println(&quot;if2&quot;); return first_match &amp;&amp; isMatch(text.substring(1), pattern.substring(1));// 第一个匹配后，后面逐个匹配 } } /** * 状态 * 首先状态 dp 一定能自己想出来。 * dp[i][j] 表示 s 的前 ii 个是否能被 p 的前 jj 个匹配 * * 转移方程 * 怎么想转移方程？首先想的时候从已经求出了 dp[i-1][j-1] 入手，再加上已知 s[i]、p[j]，要想的问题就是怎么去求 dp[i][j]。 * * 已知 dp[i-1][j-1] 意思就是前面子串都匹配上了，不知道新的一位的情况。 * 那就分情况考虑，所以对于新的一位 p[j] s[i] 的值不同，要分情况讨论： * * 考虑最简单的 p[j] == s[i] : dp[i][j] = dp[i-1][j-1] * 然后从 p[j] 可能的情况来考虑，让 p[j]=各种能等于的东西。 * * p[j] == &quot;.&quot; : dp[i][j] = dp[i-1][j-1] * * p[j] ==&quot; * &quot;: * * 第一个难想出来的点：怎么区分 *∗ 的两种讨论情况 * 首先给了 *，明白 * 的含义是 匹配零个或多个前面的那一个元素，所以要考虑他前面的元素 p[j-1]。* 跟着他前一个字符走，前一个能匹配上 s[i]，* 才能有用，前一个都不能匹配上 s[i]，* 也无能为力，只能让前一个字符消失，也就是匹配 00 次前一个字符。 * 所以按照 p[j-1] 和 s[i] 是否相等，我们分为两种情况： * * 3.1 p[j-1] != s[i] : dp[i][j] = dp[i][j-2] * 这就是刚才说的那种前一个字符匹配不上的情况。 * 比如(ab, abc * )。遇到 * 往前看两个，发现前面 s[i] 的 ab 对 p[j-2] 的 ab 能匹配，虽然后面是 c*，但是可以看做匹配 00 次 c，相当于直接去掉 c *，所以也是 True。注意 (ab, abc**) 是 False。 * 3.2 p[j-1] == s[i] or p[j-1] == &quot;.&quot;： * * 前面那个字符，能匹配 s[i]，或者 * 前面那个字符是万能的 . * 因为 . * 就相当于 . .，那就只要看前面可不可以匹配就行。 * 比如 (##b , ###b *)，或者 ( ##b , ### . * ) 只看 ### 后面一定是能够匹配上的。 * 所以要看 b 和 b * 前面那部分 ## 的地方匹不匹配。 * 第二个难想出来的点：怎么判断前面是否匹配 * dp[i][j] = dp[i-1][j] // 多个字符匹配的情况 * or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况 * or dp[i][j] = dp[i][j-2] // 没有匹配的情况 * 看 ### 匹不匹配，不是直接只看 ### 匹不匹配，要综合后面的 b b* 来分析 * 这三种情况是 oror 的关系，满足任意一种都可以匹配上，同时是最难以理解的地方： * * dp[i-1][j] 就是看 s 里 b 多不多， ### 和 ###b * 是否匹配，一旦匹配，s 后面再添个 b 也不影响，因为有 * 在，也就是 ###b 和 ###b *也会匹配。 * * dp[i][j-1] 就是去掉 * 的那部分，###b 和 ###b 是否匹配，比如 qqb qqb * * dp[i][j-2] 就是 去掉多余的 b *，p 本身之前的能否匹配，###b 和 ### 是否匹配，比如 qqb qqbb* 之前的 qqb qqb 就可以匹配，那多了的 b * 也无所谓，因为 b * 可以是匹配 00 次 b，相当于 b * 可以直接去掉了。 * * 三种满足一种就能匹配上。 * * 为什么没有 dp[i-1][j-2] 的情况？ 就是 ### 和 ### 是否匹配？因为这种情况已经是 dp[i][j-1] 的子问题。也就是 s[i]==p[j-1]，则 dp[i-1][j-2]=dp[i][j-1]。 * * 最后来个归纳： * 如果 p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]； * 如果 p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1]； * 如果 p.charAt(j) == '*'： * 如果 p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty * 如果 p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.'： * dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a * or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a * or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty * * 作者：kao-la-7 * 链接：https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/ * 来源：力扣（LeetCode） * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 * @param s * @param p * @return */ public static boolean isMatch1(String s, String p) { // 动态规划 if (s == null || p == null) { return false; } boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[0][0] = true;//dp[i][j] 表示 s 的前 i 个是否能被 p 的前 j 个匹配 for (int i = 0; i &lt; p.length(); i++) { // here's the p's length, not s's if (p.charAt(i) == '*' &amp;&amp; dp[0][i - 1]) { dp[0][i + 1] = true; // here's y axis should be i+1 } } for (int i = 0; i &lt; s.length(); i++) { for (int j = 0; j &lt; p.length(); j++) { if (p.charAt(j) == '.' || p.charAt(j) == s.charAt(i)) {//如果是任意元素 或者是对于元素匹配 dp[i + 1][j + 1] = dp[i][j]; } if (p.charAt(j) == '*') { if (p.charAt(j - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) != '.') {//如果前一个元素不匹配 且不为任意元素 dp[i + 1][j + 1] = dp[i + 1][j - 1]; } else { dp[i + 1][j + 1] = (dp[i + 1][j] || dp[i][j + 1] || dp[i + 1][j - 1]); /* dp[i][j] = dp[i-1][j] // 多个字符匹配的情况 or dp[i][j] = dp[i][j-1] // 单个字符匹配的情况 or dp[i][j] = dp[i][j-2] // 没有匹配的情况 */ } } } } return dp[s.length()][p.length()]; } // 官方解法-- enum Result { TRUE, FALSE } Result[][] memo; public boolean isMatch2(String text, String pattern) { // 自顶向下 官方 memo = new Result[text.length() + 1][pattern.length() + 1]; return dp(0, 0, text, pattern); } public boolean dp(int i, int j, String text, String pattern) { if (memo[i][j] != null) { return memo[i][j] == Result.TRUE; } boolean ans; if (j == pattern.length()) { ans = i == text.length(); } else { boolean first_match = (i &lt; text.length() &amp;&amp; (pattern.charAt(j) == text.charAt(i) || pattern.charAt(j) == '.')); if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') { ans = (dp(i, j + 2, text, pattern) || first_match &amp;&amp; dp(i + 1, j, text, pattern)); } else { ans = first_match &amp;&amp; dp(i + 1, j + 1, text, pattern); } } memo[i][j] = ans ? Result.TRUE : Result.FALSE; return ans; } public boolean isMatch3(String text, String pattern) { //动态规划，自底向上 boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1]; dp[text.length()][pattern.length()] = true; for (int i = text.length(); i &gt;= 0; i--) { for (int j = pattern.length() - 1; j &gt;= 0; j--) { boolean first_match = (i &lt; text.length() &amp;&amp; (pattern.charAt(j) == text.charAt(i) || pattern.charAt(j) == '.')); if (j + 1 &lt; pattern.length() &amp;&amp; pattern.charAt(j + 1) == '*') { dp[i][j] = dp[i][j + 2] || first_match &amp;&amp; dp[i + 1][j]; } else { dp[i][j] = first_match &amp;&amp; dp[i + 1][j + 1]; } } } return dp[0][0]; } // 官方解法--- public static void main(String[] args) { // &quot;abc&quot;,&quot;a*.&quot; // &quot;abc&quot;,&quot;ab*.&quot; System.out.println(isMatch(&quot;abc&quot;,&quot;ab*.&quot;)); /** * log * t=abc,p=ab*.,firstM=true * if2 * t=bc,p=b*.,firstM=true * if1 * t=bc,p=.,firstM=true * if2 * t=c,p=b*.,firstM=false * if1 * t=c,p=.,firstM=true * if2 * true */ int cons[] = new int[]{1,2,3}; System.out.println(getLeastCoinAmount(3,cons)); } /** * * 常见DP小问题 参考自 https://www.cnblogs.com/fefjay/p/7541760.html * * 动态规划算法是一种比较灵活的算法，针对具体的问题要具体分析，其宗旨就是要找出要解决问题的状态， * 然后逆向转化为求解子问题，最终回到已知的初始态，然后再顺序累计各个子问题的解从而得到最终问题的解。 * * 关键点就是找到状态转移方程和初始边界条件，说白了就是要找到“递推公式”和初始值，然后计算时保存每一步中间结果，最后累加判断得到结果。 */ /** * 0.求数组最值 * 求数组最值方法很多，这里使用动态规划的思想来尝试处理，以便更好地理解DP的思想。为了方便这里假设数组a[i]大小为n，要找n个数当中的最大值。 * * 设dp[i]表示第0...i个数的最大值，dp[i-1]表示第0...i-1个数的最大值，所以求前i个数的最大值时， * 已经知道前i-1个是的最大值是dp[i-1]，那么只需要比较dp[i-1]和第i个数谁大就知道了，即dp[i] = max(dp[-1], a[i])。 */ public int max(int[] a){ int len = a.length; int[] dp = new int[len]; dp[0] = a[0]; for(int i=1; i&lt;len; i++){ dp[i] = (dp[i-1] &gt; a[i]) ? dp[i-1] : a[i]; } return dp[len-1]; } /** * 1.求最大公共子序列长度 * 给定一个字符串，想要删掉某些字符使得最后剩下的字符构成一个回文串（左右对称的字符串，如abcba）， * 问最少删掉多少个字符可获得一个最长回文串。 */ /** * 本题求回文串最大长度就转化为求两个字符串的最长公共子序列（不一定连续） * 策略：字符串可以看做是字符序列，即字符数组。 * 比如有序列A=a0,a1,a2...an；有序列B=b0,b1,b2,b3...bm；设A序列和B序列的公共子序列为C=c0,c1,c2,c3...ck。 * 设L[][]为公共子序列C的长度，L[i][j]的i、j分别表示A、B序列的字符下标，L[i][j]含义是A序列a0、a1、a2...ai和B序列b0、b1、b2、 * ...bj的公共子序列的长度。 * * 1）如果A序列的i字符和B序列的j字符相等，那么就有ck=ai=bj，公共子序列C的长度L[i][j]=L[i-1][j-1]+1。 * 2）如果A序列的i字符和B序列的j字符不相等，若ai != ck则C为a0...ai-1和b0...bj的最长子序列，若bj != ck则C为a0...ai和b0...bj-1的最长子序列， * 所以此时公共子序列长度为L[i][j] = max(L[i][j-1], L[i-1][j])。 */ public static int lcs(String s){ if (s == null ) { return -1; } String rs = new StringBuilder(s).reverse().toString(); char[] chars1 = s.toCharArray(); char[] chars2 = rs.toCharArray();//获得反序的字符串 int n = chars1.length; int[][] dp = new int[n+1][n+1]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if(chars1[i] == chars2[j]){ dp[i][j] = dp[i-1][j-1] + 1; }else { dp[i][j] = dp[i][j-1] &gt; dp[i-1][j] ? dp[i][j-1] : dp[i-1][j]; } } } return n - dp[n][n]; } /** * 2.硬币凑钱问题 * 只有面值为1元、3元、5元的硬币，数量足够。现在要凑够n元，求需要的最少硬币枚数。 * * @param n 目标总钱数 * @param coins 硬币数组【1，3，5】 * @return 返回凑够n元需要的最少硬币数 */ public static int getLeastCoinAmount(int n, int[] coins){ if (coins == null || n &lt; 0) { return -1; } if (n == 0){ return 0; } int[] dp = new int[n+1]; //dp[i]=j表示凑够i元最少需要j枚硬币。数组长度设为（n+1）保证可以访问dp[n]。 dp[0] = 0; for (int i = 1; i &lt;= n; i++) { dp[i] = Integer.MAX_VALUE; } int coinValue = 0; for (int i = 1; i &lt;= n; i++) {//问题规模从小到大，直到达到目标面值 for (int j = 0; j &lt; coins.length; j++) {//遍历所有面值的硬币，j表示硬币面值的下标 coinValue = coins[j]; if (i - coinValue &gt;= 0 &amp;&amp; 1 + dp[i-coinValue] &lt; dp[i]){ //当前方案的硬币数更少，则使用当前方案 dp[i] = 1 + dp[i-coins[j]]; } } } return dp[n]; } /** * 3.最长非降子序列 * 一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 */ /** * * 定义d(i)表示前i个数中&quot;以A[i]结尾&quot;的最长非降子序列的长度。 * 对序列A1...Ai,找到的最长子序列长度d[i]分两种情况： * （1）包含最后一个数Ai,即d[i]=max{d[j]+1}(1&lt;=j&lt;i且Aj&lt;=Ai)，满足条件的Aj可能会有多个，选最大的d[j]，如果Aj都大于Ai则d[j]=0； * （2）不含最后一个数,即d[i]=d[i-1] * * 综上：d[i] = max{d[i-1], max{d[j]+1}} */ public static int longestIncreasingSubsequence(int[] a){ if (a == null) { return -1; } if (a.length &lt; 1){ return 0; } int len = a.length; int[] dp = new int[len];//dp[i]系统自动初始化为0 dp[0] = 1; for (int i = 1; i &lt; len; i++) {//迭代，求序列0...len-1的最长子序列长度 for (int j = 0; j &lt; i; j++) {//寻找Ai之前的序列，看是否有不大于Ai的数字Aj if (a[j] &lt;= a[i] &amp;&amp; dp[i] &lt; dp[j] + 1){//假设最长子序列包含最后一个数 dp[i] = dp[j] + 1; } } //寻找Ai之前的序列如果Ai都小于Aj，此时dp[i]并没有被修改仍为初始值0。所以包含最后一个数的最长子序列就只有最后一个数自身，长1 dp[i] = Math.max(1, dp[i]); //至此，已经求出了包含最后一个数的最长子序列的长度，和不包含最后一个数的最长子序列长度比较，取最大值为当前的最大长度 dp[i] = Math.max(dp[i], dp[i-1]); } return dp[len-1]; } /** * 4.经典01背包问题 * 01背包问题：一个承重（或体积）为W的背包，可选物品有n个，第i个物品分别重w[i]和价值v[i]， * 每个物品只能拿或不拿，求背包可放物品的最大价值。 */ /** * * 策略：这里的关键制约因素是背包只能承重w，而且每放入一个物品其承重就会减少。 * 因此定义maxValue=V[i][j]，数组表示目前可选物品有i个：0、1...i-1，背包承重（剩余的存放重量）为j的最大价值。 * 现在假设已经知道了(i-1)个物品且剩余承重为j的最大价值V[i-1][j]，那么考虑准备放入第i个物品的情况： * （1）如果第i个物品的重量大于背包的剩余承重w_i&gt;j，显然放不下了，所以此时V[i][j]=V[i-1][j]; * (2)w_i&lt;=j，显然可以放下第i个物品，物品可以放得下，但是一定要装进来吗？如果装进的物品价值较低且较重，无疑会影响后续物品的装入情况。 * 所以还要考虑要不要放进来的子问题，V[i][j]=max{vi+V[i-1][j-wi], V[i-1][j]}。 * * @param W * @param n * @param w * @param v * @return */ public static int knapsack(int W, int n, int[] w, int[] v){ if ( W &lt; 1 || n &lt; 1 || w == null || v == null) { return -1; } int[][] dp = new int[n+1][W+1]; //可选的物品最多可以有n个，所以行数设为n+1。最大承重是W，所以列设为W+1。 int index = 0; for (int i = 1; i &lt;= n; i++) { //物品数肯定是从1开始。dp[0][j]系统初始化为0. index = i-1; for (int j = 1; j &lt;= W ; j++) {//能装进的重量肯定是从1开始。dp[i][0]系统初始化为0. if (w[index] &gt; j){ dp[i][j] = dp[i-1][j]; }else { dp[i][j] = Math.max(dp[i - 1][j - w[index]] + v[index], dp[i - 1][j]); } } } //找出是哪些物品放入背包 boolean[] isTaken = new boolean[n];//标记是否放入背包里 for (int i = n; i &gt; 0 ; i--) { if (dp[i][W] != dp[i-1][W]){ isTaken[i-1] = true;//装入 W -= w[i-1];//装入之后背包的承重减少 System.out.println(i-1); } } return dp[n][W];//返回n个物品承重为W时的最大价值 }}","link":"/2019/12/14/algorithm/%E7%AE%97%E6%B3%95%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AFleetcode9-10/"},{"title":"nihao","text":"","link":"/2023/10/01/nihao/nihao/"},{"title":"贪心算法解析示例","text":"定义贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 思想贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停止 过程 建立数学模型来描述问题； 把求解的问题分成若干个子问题； 对每一子问题求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解。 示例假设山洞中有 n 种宝物，每种宝物有一定重量 w 和相应的价值 v，毛驴运载能力有限，只能运走 m 重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？尝试贪心策略：（1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？（2）每次挑选重量最小的宝物装入，能否得到最优解？（3）每次选取单位重量价值最大的宝物，能否使价值最高？思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限的，所以第 1 种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在总重限制的情况下保证价值最大，第 2 种策略舍弃；而第 3 种是每次选取单位重量价值最大的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量 m， 那么一定能得到价值最大。因此采用第 3 种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。 算法设计：（1）数据结构及初始化。将 n 种宝物的重量和价值存储在结构体 three（包含重量、价值、性价比 3 个成员）中，同时求出每种宝物的性价比也存储在对应的结构体 three 中，将其按照性价比从高到低排序。采用 sum 来存储毛驴能够运走的最大价值，初始化为 0。（2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于 m（毛驴运载能力），如果小于 m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m 减去放入宝物的重量；如果不小于 m，则取该宝物的一部分 m * p[i]，m=0，程序结束。m 减少到 0，则 sum 得到最大值。 完美图解假设现在有一批宝物，价值和重量如表 2-3 所示，毛驴运载能力 m=30，那么怎么装入最大价值的物品？宝物清单： 123宝物 i 1 2 3 4 5 6 7 8 9 10重量 w[i] 4 2 9 5 5 8 5 4 5 5价值 v[i] 3 8 18 6 8 20 5 6 7 15 （1）因为贪心策略是每次选择性价比（价值/重量）高的宝物，按照性价比降序排序：排序后宝物清单： 1234宝物 i 2 10 6 3 5 8 9 4 7 1重量 w[i] 2 5 8 9 5 4 5 5 5 4价值 v[i] 8 15 20 18 8 6 7 6 5 3性价比 p[i] 4 3 2.5 2 1.6 1.5 1.4 1.2 1 0.75 （2）按照贪心策略，每次选择性价比高的宝物放入：第 1 次选择宝物 2，剩余容量 30−2=28，目前装入最大价值为 8。第 2 次选择宝物 10，剩余容量 28−5=23，目前装入最大价值为 8+15=23。第 3 次选择宝物 6，剩余容量 23−8=15，目前装入最大价值为 23+20=43。第 4 次选择宝物 3，剩余容量 15−9=6，目前装入最大价值为 43+18=61。 第 5 次选择宝物 5，剩余容量 6−5=1，目前装入最大价值为 61+8=69。第 6 次选择宝物 8，发现上次处理完时剩余容量为 1，而 8 号宝物重量为 4，无法全部放入，那么可以采用部分装入的形式，装入 1 个重量单位，因为 8 号宝物的单位重量价值为1.5，因此放入价值 1×1.5=1.5，你也可以认为装入了 8 号宝物的 1/4，目前装入最大价值为69+1.5=70.5，剩余容量为 0。（3）构造最优解把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了 8 号财宝的 1/4），能够装入宝物的最大价值为 70.5。 伪代码详解（1）数据结构定义根据算法设计中的数据结构，我们首先定义一个结构体 three：struct three{double w; //每种宝物的重量double v; //每种宝物的价值double p; //每种宝物的性价比（价值/重量）｝（2）性价比排序我们可以利用 C++中的排序函数 sort（见附录 B），对宝物的性价比从大到小（非递增）排序。要使用此函数需引入头文件：#include 语法描述为：sort(begin, end)// 参数 begin 和 end 表示一个范围，分别为待排序数组的首地址和尾地址在本例中我们采用结构体形式存储，按结构体中的一个字段，即按性价比排序。如果不使用自定义比较函数，那么 sort 函数排序时不知道按哪一项的值排序，因此采用自定义比较函数的办法实现宝物性价比的降序排序：bool cmp(three a,three b)//比较函数按照宝物性价比降序排列{return a.p &gt; b.p; //指明按照宝物性价比降序排列}sort(s, s+n, cmp); //前两个参数分别为待排序数组的首地址和尾地址//最后一个参数 compare 表示比较的类型（3）贪心算法求解在性价比排序的基础上，进行贪心算法运算。如果剩余容量比当前宝物的重量大，则可以放入，剩余容量减去当前宝物的重量，已放入物品的价值加上当前宝物的价值。如果剩余容量比当前宝物的重量小，表示不可以全部放入，可以切割下来一部分（正好是剩余容量），然后令剩余容量乘以当前物品的单位重量价值，已放入物品的价值加上该价值，即为能放入宝物的最大价值。 12345678910111213for(int i = 0;i &lt; n;i++)//按照排好的顺序，执行贪心策略{if( m &gt; s[i].w )//如果宝物的重量小于毛驴剩下的运载能力，即剩余容量 { m -= s[i].w; sum += s[i].v; }else //如果宝物的重量大于毛驴剩下的承载能力 { sum += m 乘以 s[i].p; //进行宝物切割，切割一部分(m 重量)，正好达到驴子承重 break; }} 实现代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int M=1000005;struct three{ double w;//每个宝物的重量 double v;//每个宝物的价值 double p;//性价比}s[M];bool cmp(three a,three b){ return a.p&gt;b.p;//根据宝物的单位价值从大到小排序}int main(){ int n;//n 表示有 n 个宝物 double m ;//m 表示毛驴的承载能力 cout&lt;&lt;&quot;请输入宝物数量 n 及毛驴的承载能力 m ：&quot;&lt;&lt;endl; cin&gt;&gt;n&gt;&gt;m; cout&lt;&lt;&quot;请输入每个宝物的重量和价值，用空格分开： &quot;&lt;&lt;endl; for(int i=0;i&lt;n;i++) { cin&gt;&gt;s[i].w&gt;&gt;s[i].v; s[i].p=s[i].v/s[i].w;//每个宝物单位价值 } sort(s,s+n,cmp); double sum=0.0;// sum 表示贪心记录运走宝物的价值之和 for(int i=0;i&lt;n;i++)//按照排好的顺序贪心 { if( m&gt;s[i].w )//如果宝物的重量小于毛驴剩下的承载能力 { m-=s[i].w; sum+=s[i].v; } else//如果宝物的重量大于毛驴剩下的承载能力 { sum+=m * s[i].p;//部分装入 break; } } cout&lt;&lt;&quot;装入宝物的最大价值 Maximum value=&quot;&lt;&lt;sum&lt;&lt;endl; return 0;} 注意如果物品不能被分割，就不能采用贪心算法。 leetcode12. 整数转罗马数字 生活中的经验： 在以前还使用现金购物的时候，如果我们不想让对方找钱，付款的时候我们会尽量选择面值大的纸币给对方，这样才会使得我们给对方的纸币张数最少，对方点钱的时候也最方便。 本题“整数转罗马数字”也有类似的思想：在表示一个较大整数的时候，“罗马数字”的设计者不会让你都用 11 加起来，我们总是希望写出来的“罗马数字”的个数越少越好，以方便表示，并且这种表示方式还应该是唯一的。 “罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列。 罗马数字 阿拉伯数字 M 1000 CM 900 D 500 CD 400 C 100 XC 90 L 50 XL 40 X 10 IX 9 V 5 IV 4 I 1 于是，“将整数转换为罗马数字”的过程，就是用上面这张表中右边的数字作为“加法因子”去分解一个整数，目的是“分解的整数个数”尽可能少，因此，对于这道问题，类似于用最少的纸币凑成一个整数，贪心算法的规则如下： 每一步都使用当前较大的罗马数字作为加法因子，最后得到罗马数字表示就是长度最少的。 123456789101112131415161718192021222324252627public class Solution { public String intToRoman(int num) { // 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中 // 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想 int[] nums = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}; String[] romans = {&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;}; StringBuilder stringBuilder = new StringBuilder(); int index = 0; while (index &lt; 13) { // 特别注意：这里是等号 while (num &gt;= nums[index]) { // 注意：这里是等于号，表示尽量使用大的&quot;面值&quot; stringBuilder.append(romans[index]); num -= nums[index]; } index++; } return stringBuilder.toString(); }}作者：liweiwei1419链接：https://leetcode-cn.com/problems/integer-to-roman/solution/tan-xin-suan-fa-by-liweiwei1419/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 参考文章:参考链接1参考链接2","link":"/2019/12/22/algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E7%A4%BA%E4%BE%8B/"}],"tags":[{"name":"二分查找","slug":"二分查找","link":"/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"分治算法","slug":"分治算法","link":"/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"贪心算法","slug":"贪心算法","link":"/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"双指针","slug":"双指针","link":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"递归回溯","slug":"递归回溯","link":"/tags/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"最长回文","slug":"最长回文","link":"/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87/"},{"name":"Z字变换","slug":"Z字变换","link":"/tags/Z%E5%AD%97%E5%8F%98%E6%8D%A2/"},{"name":"反转整数","slug":"反转整数","link":"/tags/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"name":"字符串转整数","slug":"字符串转整数","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"name":"中心扩展","slug":"中心扩展","link":"/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95/"},{"name":"最优解","slug":"最优解","link":"/tags/%E6%9C%80%E4%BC%98%E8%A7%A3/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}],"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.09.20：icarus4.0适配–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95%额外： 追了很多剧总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈 彭小苒 唐艺昕 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '973937d9fd966587fe5d', clientSecret: '0b9c15f9f80fc157ade7259c8870513c6a08c4b9', id: 'selftalk', repo: 'comment', owner: 'ssrskl', admin: \"ssrskl\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}]}